<html>

<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1252">
<title>LenMus coding standards </title>

</head>

<body>

<H2>LenMus coding standards</H2>

<p>This guide is intended for people who are
(or intending to start) writing code for the LenMus project. This guidelines
are based on the the <A href="">wxWidgets Programmer Style
Guide</A> by Vadim Zeitlin</p>

<p>The guide is separated into two parts:</p>

<p><a href="#lenmus_rules">LenMus rules</a></p>

<p>This part details the LenMus code
organization and its goal it to make LenMus as uniform as possible without
imposing too many restrictions on the programmer.</p>

<p><a href="#portability">C++ portability rules</a></p>

<p>This section addresses the general
compatibility and portability issues and is not LenMus-specific. The advices in
this part will hopefully help you to write programs which compile and run on
greater variety of platforms</p>

<a name="lenmus_rules"/>
<p>LenMus Rules</p>

<ul>
 <li>Files location and naming conventions </li>
 <ol start=1 type=1>
  <li><a href="#include_guards">Include guards</a></li>
  <li><a href="#pch">Precompiled headers</a></li>
 </ol>
</ul>

<p>&nbsp;</p>

<ul>
 <li>File layout and indentation </li>
 <ol start=1 type=1>
  <li><a href="#wxwin_header">LenMus
      standard header</a> </li>
  <li><a href="#indentation">Indent your code with 4 spaces (no tabs!)</a> </li>
  <li><a href="#class_decl">Order of parts in a class declarations</a> </li>
 </ol>
</ul>

<p>&nbsp;</p>

<ul>
 <li>More about naming conventions </li>
 <ol start=1 type=1>
  <li><a href="#wx_prefix">Use "lm" or "LM" prefix for all public symbols</a></li>
  <li><a href="#set_get">Use Set/Get prefixes for accessors</a></li>
  <li><a href="#constants">lmNAMING_CONSTANTS</a></li>
 </ol>
</ul>

<p>&nbsp;</p>

<ul>
 <li>Miscellaneous </li>
 <ol start=1 type=1>
  <li><a
      href="forward_decl#forward_decl">Use
      forward declarations whenever possible</a> </li>
  <li><a
      href="debug_macros#debug_macros">Use
      debugging macros</a> </li>
 </ol>
</ul>

<p
>&nbsp;</p>

<ul>
 <li>File location and naming conventions </li>
 <ol start=1 type=1>
  <li><a name="include_guards">Include guards</a> </li>
 </ol>
</ul>

<p>To minimize the compile
time C++ programmers often use so called include guards: for example, in the
header file foo.h you might have </p>

<p>#ifndef
_FOO_H_</p>

<p>#define
_FOO_H_</p>

<p>&nbsp;</p>

<p>...
all header contents ...</p>

<p>&nbsp;</p>

<p>#endif</p>

<p>&nbsp;</p>

<p>In this way, the
header will only be included once for the compilation of any .cpp (of course,
it still will be included many times for the compilation of the whole project,
so it has nothing to do with precompiled headers). wxWidgets is no exception
and also uses include guards which should use the above form, except for
top-level headers which include files with identical names, in which case you
should use _FOO_H_BASE_. </p>

<ul>
 <ol start=2 type=1>
  <li><a name=pch>Precompiled headers</a> </li>
 </ol>
</ul>

<p>The precompiled
headers greatly (we're speaking about orders of hundreds of percent here)
reduce the compilation time. wxWidgets uses them if the target compiler
supports them (it knows about MS Visual C++, Borland C++ and g++). You should
include all the headers included from only inside &quot;#if !USE_PRECOMP&quot; to avoid unnecessary overhead in the
case when the precompiled headers are used. </p>

<p>The start of a cpp
implementation file after the heading might look like this: </p>

<p>#ifdef
__GNUG__</p>

<p>#pragma
implementation &quot;bitmap.h&quot;</p>

<p>#endif</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>#include
&quot;wx/wxprec.h&quot;</p>

<p>&nbsp;</p>

<p>#ifdef
__BORLANDC__</p>

<p>#pragma
hdrstop</p>

<p>#endif</p>

<p>&nbsp;</p>

<p>#ifndef
WX_PRECOMP</p>

<p>#include
&lt;stdio.h&gt;</p>

<p>#include
&quot;wx/setup.h&quot;</p>

<p>#include
&quot;wx/list.h&quot;</p>

<p>#include
&quot;wx/utils.h&quot;</p>

<p>#include
&quot;wx/app.h&quot;</p>

<p>#include
&quot;wx/palette.h&quot;</p>

<p>#include
&quot;wx/bitmap.h&quot;</p>

<p>#include
&quot;wx/icon.h&quot;</p>

<p>#endif</p>

<p>&nbsp;</p>

<p>#include
&quot;wx/msw/private.h&quot;</p>

<p>#include
&quot;assert.h&quot;</p>

<p>Any header file
should containg the following lines: </p>

<p>#ifdef
__GNUG__</p>

<p> 
#pragma interface &quot;foo.h&quot;</p>

<p>#endif</p>

<p>and the
corresponding .cpp file: </p>

<p>#ifdef
__GNUG__</p>

<p> 
#pragma implementation &quot;foo.h&quot;</p>

<p>#endif</p>

<p>for g++ compilation.
</p>

<ul>
 <li>File layout and indentation </li>
 <ol start=1 type=1>
  <li><a name="wxwin_header">LenMus standard header</a>.
      </li>
 </ol>
</ul>

<p>All files must start
with the RCS-ID line, followed by the GNU Public Licence banner and the Doxygen
file description. See, for example, any file in src folder.<a
name=indentation></a></p>

<ul>
 <ol start=2 type=1>
  <li>Indent your code with 4 spaces. Do not use tabs!</li>
 </ol>
</ul>

<p>Tabs cause trouble
when people use different editors and have different settings. PLEASE, do not
use Tabs, replace then by 4 spaces.</p>

<a name="class_decl"></a> 
<H3>3. Order of parts in a class declarations</H3>

<p>Please put the
public parts of the class first, then protected, then private. The idea is to
be able to quickly see the public API of a class without having to read through
uninteresting implementation details in the public sections. </p>

<p>Also, please put all
macros which must be used in the class declaration (such as BEGIN_EVENT_TABLE) in the end of it as, again, these are
implementation details and shouldn't get in the way of the person who is
reading the file. </p>

<H2>More about naming conventions </H2>

<a name="wx_prefix" />
<H3>1. Use "lm" or "LM" prefix for all public symbols</H3>

<p>"lm" should be used
for functions and classes, "LM" for macros. </p>

<a name="set_get" />
<H3>2. Use Set/Get prefixes for accessors</H3>

<p>There is a
convention in LenMus to prefix the accessors (i.e. any simple, in general,
inline function which does nothing else except changing or returning the value
of a member variable) with either Set or Get. </p>

<a name="constants" />
<H3>3. lmNAMING_CONSTANTS</H3>

<p>The constants in LenMus
code should be defined using enum
C++ keyword (and not with #define or static
const int). They should be
declared in the global scope (and not inside class declaration) and their names
should start with the lm
prefix. Finally, the constants should be in all capital letters (except the prefix
"lm") to make it easier to distinguish them from the variables with underscores
separating the words. </p>

<p>For example,
file-related constants should be declared like this: </p>

<p>enum</p>

<p>{</p>

<p>   
wxFILEOPEN_READ,</p>

<p>   
wxFILEOPEN_WRITE,</p>

<p>   
wxFILEOPEN_READWRITE</p>

<p>};</p>

<ul>
 <ol start=4 type=1>
  <li>Miscellaneous </li>
  <ol start=1 type=1>
   <li><a
       name="forward_decl">Use forward
       declarations whenever possible</a> </li>
  </ol>
 </ol>
</ul>

<p>It's a really
trivial piece of advice, but remember that using forward declarations instead
of including the header of corresponding class is better because not only does
it minimize the compile time, it also simplifies the dependencies between
different source files. </p>

<p>On a related
subject, in general, you should try not to include other headers from a header
file. </p>

<ul>
 <ol start=4 type=1>
  <ol start=2 type=1>
   <li>Use debugging macros </li>
  </ol>
 </ol>
</ul>

<p>wxWidgets provides
the debugging macros wxASSERT, wxFAIL and wxCHECK_RET in file. Please use them as often as you can -- they will never do you
any harm but can greatly simplify the bug tracking both for you and for others.
</p>

<p>Also, please use wxFAIL_MSG(&quot;not
implemented&quot;) instead of
writing stubs for not (yet) implemented functions which silently return
incorrect values -- otherwise, a person using a not implemented function has no
idea that it is, in fact, not implemented. </p>

<p>As all debugging
macros only do something useful if the symbol __WXDEBUG__ is defined, you should compile your
programs in debug mode to profit from them. </p>


<a name="portability" />
<p>General C++ rules for portability</p>

<ul>
 <li>New or not widely supported C++
     features </li>
 <ol start=1 type=1>
  <li><a
      href="no_templates#no_templates">Don't
      use C++ templates</a> </li>
  <li><a
      href="no_exceptions#no_exceptions">Don't
      use C++ exceptions</a> </li>
  <li><a
      href="no_rtti#no_rtti">Don't use
      RTTI</a> </li>
  <li><a
      href="no_namespaces#no_namespaces">Don't
      use namespaces</a> </li>
  <li><a
      href="no_stl#no_stl">Don't use STL</a>
      </li>
  <li><a
      href="no_fordecl#no_fordecl">Don't declare variables inside for()</a> </li>
  <li><a
      href="no_nestedclasses#no_nestedclasses">Don't
      use nested classes</a> </li>
  <li><a
      href="no_newlogicalops#no_newlogicalops">Don't use new logical operators keywords</a> </li>
 </ol>
</ul>

<p>&nbsp;</p>

<ul>
 <li>Other compiler limitations </li>
 <ol start=1 type=1>
  <li><a
      href="no_ternarywithobjects#no_ternarywithobjects">Use
      ternary operator ?: carefully</a> </li>
  <li><a
      href="no_autoaggregate#no_autoaggregate">Don't use initializers with automatic arrays</a> </li>
  <li><a
      href="no_dtorswithoutctor#no_dtorswithoutctor">Always have at least one constructor in a class with
      destructor</a> </li>
 </ol>
</ul>

<p>&nbsp;</p>

<ul>
 <li>General recommendations </li>
 <ol start=1 type=1>
  <li><a
      href="no_cppcommentsinc#no_cppcommentsinc">No C++ comments in C code</a> </li>
  <li><a
      href="no_globals#no_globals">No
      global variables with constructor</a> </li>
  <li><a
      href="no_warnings#no_warnings">Turn on all warnings and eradicate them</a> </li>
  <li><a
      href="no_assume_sizeof#no_assume_sizeof">Don't rely on sizeof(int) == 2...</a> </li>
  <li><a
      href="no_assignment_in_if#no_assignment_in_if">No
      assignments in conditional expressions</a> </li>
  <li><a
      href="no_comment_code#no_comment_code">Use #if 0 rather than
      comments to temporarily disable blocks of code</a> </li>
  <li><a
      href="no_overloaded_virtuals#no_overloaded_virtuals">Avoid
      overloaded virtual functions</a> </li>
  <li><a
      href="no_bool_params#no_bool_params">Don't
      use boolean function arguments</a> </li>
  <li><a
      href="no_extra_semicolon#no_extra_semicolon">Don't use extra semi-colons on top level</a> </li>
 </ol>
</ul>

<p>&nbsp;</p>

<ul>
 <li>Unix/DOS differences </li>
 <ol start=1 type=1>
  <li><a
      href="use_cpp_ext#use_cpp_ext">Use .cpp for C++ source file extension</a> </li>
  <li><a
      href="no_backslash#no_backslash">Don't use backslash ('\\') in #includes</a> </li>
  <li><a
      href="no_carriagereturn#no_carriagereturn">Avoid carriage returns in cross-platform code</a> </li>
  <li><a
      href="no_caps_in_filenames#no_caps_in_filenames">Use
      only lower letter filenames</a> </li>
  <li><a
      href="no_incomplete_files#no_incomplete_files">Terminate the files with a new-line</a> </li>
  <li><a
      href="no_case_only_diff#no_case_only_diff">Avoid globals differing by case only</a> </li>
 </ol>
</ul>

<p>&nbsp;</p>

<ul>
 <li>Style choices </li>
 <ol start=1 type=1>
  <li><a
      href="naming_conv#naming_conv">Naming conventions: use m_ for members</a> </li>
  <li><a
      href="no_void_param#no_void_param">Don't use void for functions
      without arguments</a> </li>
  <li><a
      href="no_const_int#no_const_int">Don't use const for non
      pointer/reference arguments</a> </li>
  <li><a
      href="null_not_zero#null_not_zero">Use
      NULL
      rather than 0</a>
      </li>
 </ol>
</ul>

<p>&nbsp;</p>

<p>&nbsp;</p>

<div class=MsoNormal align=center style='margin-bottom:0cm;margin-bottom:.0001pt;
text-align:center;text-indent:0cm'>

<hr size=2 width="100%" align=center>

</div>

<p>General C++ Rules</p>

<ul>
 <li>New or not widely supported C++
     features </li>
</ul>

<p>The usage of all
features in this section is not recommended for one reason: they appeared in
C++ relatively recently and are not yet supported by all compilers. Moreover,
when they're supported, there are differences between different vendor's
implementations. It's understandable that you might love one (or all) of these
features, but you surely can write C++ programs without them. Where possible,
workarounds to compensate for absence of your favourite C++ abilities are
indicated. </p>

<p>Just to suppress any
doubts that there are compilers which don't support these new features, you can
think about Win16 (a.k.a. Win 3.1) compilers, <i>none</i> of which supports <i>any</i>
feature from the list below. </p>

<ul>
 <ol start=1 type=1>
  <li><a
      name="no_templates"></a>Don't use C++
      templates </li>
 </ol>
</ul>

<p>Besides the reasons
mentioned above, template usage also makes the program compile much slower
(200%-300% is not uncommon) and their support even in the compilers which have
had it for a long time is far from perfect (the best example is probably gcc). </p>

<p><u>Workaround</u>: The things you would like to use
templates for are, most commonly, polymorphic containers (in the sense that
they can contain objects of any type without compromising C++ type system, i.e.
using void
* is out of question). wxWidgets
provides dynamic arrays and lists which are sufficient in 99% of cases --
please don't hesitate to use them. Lack of template is not a reason to use
static arrays or type-less (passing by void *) containers. </p>

<ul>
 <ol start=2 type=1>
  <li><a
      name="no_exceptions"></a>Don't use C++
      exceptions </li>
 </ol>
</ul>

<p>The C++ exception
system is an error-reporting mechanism. Another reasons not to use it, besides
portability, are the performance penalty it imposes (small, but, at least for
current compilers, non-zero), and subtle problems with memory/resource
deallocation it may create (the place where you'd like to use C++ exceptions
most of all are the constructors, but you need to be very careful in order to
be able to do it). </p>

<p><u>Workaround</u>: there is no real workaround, of course,
or the exceptions wouldn't have been added to the language. However, there are several rules which might help
here: </p>

<ul>
 <ol start=2 type=1>
  <ol start=1 type=1>
   <li>Every function returns an integer
       (or at least boolean) error code. </li>
  </ol>
 </ol>
</ul>

<p>There is no such
thing as a function that never fails -- even if it can't fail now, it might do
it later, when modified to be more powerful/general. Put the int or bool return type from the very beginning! </p>

<ul>
 <ol start=2 type=1>
  <ol start=2 type=1>
   <li>Every function you call may fail --
       check the return code! </li>
  </ol>
 </ol>
</ul>

<p>Never rely on the
function's success, always test for a possible error. </p>

<ul>
 <ol start=2 type=1>
  <ol start=3 type=1>
   <li>Tell the user about the error, don't
       silently ignore them. </li>
  </ol>
 </ol>
</ul>

<p>Exceptions are
always caught and, normally, processed when they're caught. In the same manner,
the error return code must always be processed somehow. You may choose to
ignore it, but at least tell the user that something wrong happened using <a href="http://www.wxwidgets.org/TODO">wxLogError</a> or <a
href="http://www.wxwidgets.org/TODO">wxLogWarning</a> functions. All wxWidgets functions (must) log the
error messages on failure -- this can be disabled by using <a href="http://www.wxwidgets.org/TODO">wxLogNull</a>
object before calling it. </p>

<p>Examples: </p>

<ul>
 <ol start=2 type=1>
  <ol start=3 type=1>
   <ul type=square>
    <li><i>Wrong</i>:
        </li>
   </ul>
  </ol>
 </ol>
</ul>

<p>§&nbsp;&nbsp;&nbsp;&nbsp; void
ReadAddressBookFile(const wxString&amp; strName)</p>

<p>{</p>

<p>  wxFile file;</p>

<p>&nbsp;</p>

<p>  if ( !file.Open(strFile) )</p>

<p>    return;</p>

<p>&nbsp;</p>

<p>  ...process it...</p>

<p>}</p>


<ul>
 <ol start=2 type=1>
  <ol start=3 type=1>
   <ul type=square>
    <li><i>Correct</i>:
        </li>
   </ul>
  </ol>
 </ol>
</ul>

<p>&nbsp;</p>

<p>§&nbsp;&nbsp;&nbsp;&nbsp; bool
ReadAddressBookFile(const wxString&amp; strName)</p>

<p>{</p>

<p>  wxFile file;</p>

<p>&nbsp;</p>

<p>  if ( !file.Open(strFile) )
{</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>§&nbsp;&nbsp;&nbsp;&nbsp;     wxLogError(&quot;Can't
read address book from '%s'!&quot;,</p>

<p>§&nbsp;&nbsp;&nbsp;&nbsp;                strName.c_str());</p>

<p>    return false;</p>

<p>  }</p>

<p>&nbsp;</p>

<p>  ...process it...</p>

<p>&nbsp;</p>

<p>  return true;</p>

<p>}</p>


<p>or, if it's not an
error if file doesn't exist (here we could just check its existence, but let's
suppose that there is no wxFile::Exists()) we can also write: </p>

<p>&nbsp;</p>

<p>bool
ReadAddressBookFile(const wxString&amp; strName)</p>

<p>{</p>

<p> 
wxFile file;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p> 
{</p>

<p>   
wxLogNull noLog;</p>

<p>   
if ( !file.Open(strFile) )</p>

<p>     
return false;</p>

<p> 
}</p>

<p>&nbsp;</p>

<p> 
...process it...</p>

<p>&nbsp;</p>

<p> 
return true;</p>

<p>}</p>

<p>       
</p>

<ul>
 <ol start=3 type=1>
  <li><a
      name="no_rtti"></a>Don't use RTTI </li>
 </ol>
</ul>

<p>RTTI stands for
Run-Time Type Information and there is probably no other reason not to use it
except the portability issue and the fact that it adds sizeof(void *) bytes to any class having virtual functions
(at least, in the implementations I'm aware of). </p>

<p><u>Workaround</u>: use wxWidgets RTTI system which allows
you to do almost everything which the new C++ RTTI, except that, of course, you
have to use macros instead of the (horrible looking, BTW) dynamic_cast. </p>

<ul>
 <ol start=4 type=1>
  <li><a
      name="no_namespaces"></a>Don't use
      namespaces </li>
 </ol>
</ul>

<p>This topic is
subject to change with time, however for the moment all wxWidgets
classes/functions live in the global namespace. </p>

<p><u>Workaround</u>: None. </p>

<ul>
 <ol start=5 type=1>
  <li><a
      name="no_stl"></a>Don't use STL </li>
 </ol>
</ul>

<p>STL is the new C++
standard library, proposing all kinds of template containers and generic
algorithm implementations. Templates are the heart (and almost everything else)
of the library, so its usage is out of question. Besides, even with the
compilers which do support templates, STL has many of its own problems, there are
many &quot;not 100% standard compatible&quot; vendor implementations, none of
existing debuggers understands its complicated data structures, ... the list
can go on (almost) forever. </p>

<p><u>Workaround</u>: Use wxString, dynamic arrays and lists
and other wxWidgets classes. wxString has many of the most often used functions
of std::string STL class (typedef to be precise). </p>

<ul>
 <ol start=6 type=1>
  <li><a
      name="no_fordecl"></a>Don't
      declare variables inside for() </li>
 </ol>
</ul>

<p>The scope of a
variable declared inside for()
statement changed several years ago, however many compilers still will complain
about second declaration of i
in the following code: </p>

<p> 
for ( int i = 0; i &lt; 10; i++ ) {</p>

<p>   
...</p>

<p> 
}</p>

<p>&nbsp;</p>

<p> 
...</p>

<p>&nbsp;</p>

<p> 
for ( int i = 0; i &lt; 10; i++ ) {</p>

<p>   
...</p>

<p> 
}</p>

<p>even though if it's
perfectly legal now. </p>

<p><u>Workaround</u>: write this instead: </p>

<p> 
int i;</p>

<p> 
for ( i = 0; i &lt; 10; i++ ) {</p>

<p>   
...</p>

<p> 
}</p>

<p>&nbsp;</p>

<p> 
...</p>

<p>&nbsp;</p>

<p> 
for ( i = 0; i &lt; 10; i++ ) {</p>

<p>   
...</p>

<p> 
}</p>

<p>or, even better, use
different names for the variables in the different for loops (in particular,
avoid mute variable names like i
above) -- then you can declare them in the loop statement and don't pollute the
outer name space with local loop variables. </p>

<ul>
 <ol start=7 type=1>
  <li><a
      name="no_nestedclasses"></a>Don't use
      nested classes </li>
 </ol>
</ul>

<p>Nested classes are,
without doubt, a very good thing because they allow to hide &quot;private&quot;
(in the sense that they're used only inside the library) classes and,
generally, put the related things together. </p>

<p>Unfortunately, some
compilers have trouble understanding them, so we must sacrifice the ideals of
software design to get a working program in this case. </p>

<p><u>Workaround</u>: instead of </p>

<p>&nbsp;</p>

<p> 
class PublicLibClass {</p>

<p> 
...</p>

<p> 
private:</p>

<p>   
class PrivateLibClass { ... } m_object;</p>

<p> 
};</p>

<p>you can try the
following: </p>

<p>&nbsp;</p>

<p> 
class PrivateLibClass;</p>

<p> 
class PublicLibClass {</p>

<p> 
...</p>

<p> 
private:</p>

<p>  
class PrivateLibClass *m_pObject;</p>

<p> 
};</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p> 
class PrivateLibClass { ... };</p>

<p>&nbsp;</p>

<p> 
PublicLibClass::PublicLibClass()</p>

<p> 
{</p>

<p>   
m_pObject = new PrivateLibClass;</p>

<p>&nbsp;</p>

<p>   
...</p>

<p> 
}</p>

<p>&nbsp;</p>

<p> 
PublicLibClass::~PublicLibClass()</p>

<p> 
{</p>

<p>   
delete m_pObject;</p>

<p> 
}</p>

<p>A nice side effect
is that you don't need to recompile all the files including the header if you
change the PrivateLibClass declaration (it's an example of a more general
interface/implementation separation idea). </p>

<ul>
 <ol start=8 type=1>
  <li><a
      name="no_newlogicalops"></a>Don't
      use new logical operators keywords </li>
 </ol>
</ul>

<p>The C++ standard has
introduced the following new reserved words: or, and,
not, xor, bitand, bitor, compl,
and_eq, or_eq, not_eq,
or_eq which can be used instead of the usual C
operations &amp;&amp;, ||, ~ etc. </p>

<p>This wonderful (and
not backwards compatible in addition to being absolutely useless) new feature
means that these new keywords should not be used as the variable names -- even
if the current compilers usually will accept this, your code will break in the
future. For most of the keywords, using them as variable names is quite
unlikely, but or and compl were used in the wxWidgets sources which
seems to indicate that they are the most likely candidates. </p>

<p>It goes without
saying that these new keywords should not be used instead of the tradional C
operators neither both because most existing compilers don't ship with &lt;iso646.h&gt; header needed to be able to use the new
keywords and because using them in C code makes it less readable. </p>

<p>&nbsp;</p>

<ul>
 <li>Other compiler limitations </li>
</ul>

<p>This section lists
the less obvious limitations of the current C++ compilers which are less
restrictive than the ones mentioned in the previous section but are may be even
more dangerous as a program which compiles perfectly well on some platform and
seems to use only standard C++ featurs may still fail to compile on another
platform and/or with another compiler. </p>

<ul>
 <ol start=1 type=1>
  <li><a
      name="no_ternarywithobjects"></a>Use
      ternary operator ?: carefully </li>
 </ol>
</ul>

<p>The ternary operator
?: shouldn't be used with objects (i.e. if
any of its operands are objects) because some compilers (notably Borland C++)
fail to compile such code. </p>

<p><u>Workaround</u>: use if/else instead. </p>

<p>   
wxString s1, s2;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>   
wxString s = s1.Len() &lt; s2.Len() ? s1 : s2;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>   
wxString s;</p>

<p>   
if ( s1.Len() &lt; s2.Len() )</p>

<p>       
s = s1;</p>

<p>    else</p>

<p>       
s = s2;</p>

<ul>
 <ol start=2 type=1>
  <li><a
      name="no_autoaggregate"></a>Don't
      use initializers with automatic arrays </li>
 </ol>
</ul>

<p>The initializers for
automatic array variables are not supported by some older compilers. For
example, the following line </p>

<p>   
int daysInMonth[12] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };</p>

<p>will fail to compile
with HP-UX C++ compiler. </p>

<p><u>Workaround</u>: either make the array static or
initialize each item separately: in the (stupid) example above, the array should
be definitely declared as static const (assuming that the leap years are dealt with
elsewhere somehow...) which is ok. When an array is really not const, you
should initialize each element separately. </p>

<ul>
 <ol start=3 type=1>
  <li><a
      name="no_dtorswithoutctor"></a>Always
      have at least one constructor in a class with destructor </li>
 </ol>
</ul>

<p>It is a good rule to
follow in general, but some compilers (HP-UX) enforce it. So even if you are
sure that the default constructor for your class is ok but it has a destructor,
remember to add an empty default constructor to it. </p>

<p>&nbsp;</p>

<ul>
 <li>General recommendations </li>
</ul>

<p>While the
recommendations in the previous section may not apply to you if you're only
working with perfect compilers which implement the very newest directives of
C++ standard, this section contains compiler- (and language-) independent advice
which must</b> be followed if you wish to write correct, i.e. working,
programs. It also contains some C/C++ specific remarks in the end which are
less important. </p>

<ul>
 <ol start=1 type=1>
  <li><a
      name="no_cppcommentsinc">No
      C++ comments in C code</a> </li>
 </ol>
</ul>

<p>Never use C++
comments in C code -- not all C compilers/preprocessors understand them.
Although we're mainly concerned with C++ here, there are several files in
wxWidgets sources tree which are compiled with C compiler. Among them are include/wx/setup.h and include/wx/expr.h. Another thing related to C vs C++
preprocessor differences is that some old C preprocessors require that all
directives start in the first column (while it's generally allowed to have any
amount of whitespace before them in C++), so you should start them in the
beginning of the line in files which are compiled with C compiler. </p>

<ul>
 <ol start=2 type=1>
  <li><a
      name="no_globals"></a>No global
      variables with constructors </li>
 </ol>
</ul>

<p>In C++, the
constructors of global variables are called before the main() function (or WinMain() or any other program entry point) starts
executing. Thus, there is no possibility to initialize <i>anything</i> before
the constructor call. The order of construction is largely
implementation-defined, meaning that there is no guarantee that one global
object will be initialized before another one (except if they are both defined
in the same translation unit, i.e. .cpp file). Most importantly, no custom
memory allocation operators are installed at the moment of execution of global
variables constructors, so a (less restrictive) rule is that you should have no
global variables which allocate memory (or do anything else non-trivial) in the
constructor. Of course, if an object doesn't allocate memory in its constructor
right now, it may start making it later, so you can only be sure about this if
you don't use <i>any</i> variables of object (as opposed to simple: int, ...) types. Example: currently, wxString
doesn't allocate memory in its default constructor, so you might think that
having a global (initially) empty wxString is safe. However, if wxString starts
allocating some minimal amount of memory in its default constructor (which
doesn't look unreasonable), you would have all kinds of problems with new and delete operators (overloaded in wxWidgets),
especially because the first new
called is the standard one (before wxWidgets overloads them) and delete will be the overloaded operator. </p>

<ul>
 <ol start=3 type=1>
  <li><a
      name="no_warnings"></a>Turn
      on all warnings and eradicate them </li>
 </ol>
</ul>

<p>Give the compiler a
chance to help you -- turn on all warnings! You should always use the maximum
available warning level of your compiler and understand and correct each of
them. If, for whatever reasons, a compiler gives a warning on some perfectly
legal line of code and you can't change it, please insert a comment indicating
it in the code. Most oftenly, however, all compiler warnings may be avoided
(not suppressed!) with minimal changes to your code. </p>

<ul>
 <ol start=4 type=1>
  <li><a
      name="no_assume_sizeof"></a>Don't
      rely on sizeof(int) == 2... </li>
 </ol>
</ul>

<p>You should never
assume any absolute constraints on data type sizes. Currently, we have 16-bit,
32-bit and 64-bit machines and even inside each class data type sizes are
different. A small table illustrates it
quite well: </p>

<table class=MsoNormalTable border=1 cellpadding=0 width="100%"
 style='width:100.0%;margin-left:72.0pt'>
 <tr>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p
  text-align:left;text-indent:0cm'>Architecture/OS</p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p
  text-align:left;text-indent:0cm'>sizeof(short)</p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p
  text-align:left;text-indent:0cm'>sizeof(int)</p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p
  text-align:left;text-indent:0cm'>sizeof(long)</p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p
  text-align:left;text-indent:0cm'>sizeof(void *)</p>
  </td>
 </tr>
 <tr>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p
  text-align:left;text-indent:0cm'>1/Windows 3.1</p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p
  text-align:left;text-indent:0cm'>2</p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p
  text-align:left;text-indent:0cm'>2</p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p
  text-align:left;text-indent:0cm'>4</p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p
  text-align:left;text-indent:0cm'>2 or 4</p>
  </td>
 </tr>
 <tr>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p
  text-align:left;text-indent:0cm'>1/Windows 95</p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p
  text-align:left;text-indent:0cm'>2</p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p
  text-align:left;text-indent:0cm'>4</p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p
  text-align:left;text-indent:0cm'>4</p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p
  text-align:left;text-indent:0cm'>4</p>
  </td>
 </tr>
 <tr>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p
  text-align:left;text-indent:0cm'>ia64/Win64</p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p
  text-align:left;text-indent:0cm'>2</p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p
  text-align:left;text-indent:0cm'>4</p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p
  text-align:left;text-indent:0cm'>4</p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p
  text-align:left;text-indent:0cm'>8</p>
  </td>
 </tr>
 <tr>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p
  text-align:left;text-indent:0cm'>Alpha/Linux</p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p
  text-align:left;text-indent:0cm'>2</p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p
  text-align:left;text-indent:0cm'>4</p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p
  text-align:left;text-indent:0cm'>8</p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p
  text-align:left;text-indent:0cm'>8</p>
  </td>
 </tr>
</table>

<ul>
 <ol start=5 type=1>
  <li><a
      name="no_assignment_in_if"></a>No
      assignments in conditional expressions </li>
 </ol>
</ul>

<p>Although close to
the heart of many C programmers (I plead guilty), code like classical if ( (c =
getchar()) != EOF ) is bad
because it prevents you from enabling &quot;assignment in conditional
expression&quot; warning (see also <a
href="#no_warnings">above</a>)
which is helpful to detect common mistypes like if ( x = 2 ) instead of if ( x == 2 ). </p>

<ul>
 <ol start=6 type=1>
  <li><a
      name="no_comment_code"></a>Use
      #if
      0 rather than
      comments to temporarily disable blocks of code </li>
 </ol>
</ul>

<p>If you have to
temporarily disable some code, use </p>

<p> 
#if 0</p>

<p>   
...</p>

<p> 
#endif</p>

<p>instead of </p>

<p> 
/*</p>

<p>   
...</p>

<p> 
*/</p>

<p>The reason is
simple: if there are any /* ... */ comments inside ...
the second version will, of course, miserably fail. </p>

<ul>
 <ol start=7 type=1>
  <li><a
      name="no_overloaded_virtuals"></a>Avoid
      overloaded virtual functions </li>
 </ol>
</ul>

<p>You should avoid
having overloaded virtual methods in a base class because if any of them is
overriden in a derived class, then all others must be overriden as well or it
would be impossible to call them on an object of derived class. For example,
the following code: </p>

<p>   
class Base</p>

<p>   
{</p>

<p>   
public:</p>

<p>       
virtual void Read(wxFile&amp; file);</p>

<p>       
virtual void Read(const wxString&amp; filename);</p>

<p>   
};</p>

<p>&nbsp;</p>

<p>   
class Derived : public Base</p>

<p>   
{</p>

<p>   
public:</p>

<p>       
virtual void Read(wxFile&amp; file) { ... }</p>

<p>   
};</p>

<p>&nbsp;</p>

<p>   
...</p>

<p>&nbsp;</p>

<p>   
Derived d;</p>

<p>   
d.Read(&quot;some_filename&quot;);</p>

<p>will fail to compile
because the base class function taking filename is hidden by the virtual function
overriden in the derived class (this is known as [virtual] function name hiding
problem in C++). </p>

<p>The standard
solution to this problem in wxWidgets (where we have such situations quite
often) is to make both Read()
functions not virtual and introduce a single virtual function DoRead(). Usually, it makes sense because the
function taking a filename is (again, usually) implemented in terms of the
function reading from a file anyhow (but making only this functions not virtual
won't solve the above problem!). </p>

<p>So, the above
declarations should be written as: </p>

<p>   
class Base</p>

<p>   
{</p>

<p>   
public:</p>

<p>       
void Read(wxFile&amp; file);</p>

<p>       
void Read(const wxString&amp; filename);</p>

<p>&nbsp;</p>

<p>   
protected:</p>

<p>       
virtual void DoRead(wxFile&amp; file);</p>

<p>   
};</p>

<p>&nbsp;</p>

<p>   
class Derived : public Base</p>

<p>   
{</p>

<p>   
protected:</p>

<p>       
virtual void DoRead(wxFile&amp; file) { ... }</p>

<p>   
};</p>

<p>This technique is
widely used in many of wxWidgets classes -- for example, wxWindow has more than a dozen of DoXXX() functions which allows to have many
overloaded versions of commonly used methods such as SetSize() </p>

<ul>
 <ol start=8 type=1>
  <li><a
      name="no_bool_params"></a>Don't use
      boolean function arguments </li>
 </ol>
</ul>

<p>Using boolean
parameters in the public function usually is a bad API design idea for two
reasons which are explained below using the example of wxWidgets wxExecute function used to launch an external
process but which are, in fact, quite general: </p>

<ul>
 <ol start=8 type=1>
  <ol start=1 type=1>
   <li><i>Readability:</i> </li>
  </ol>
 </ol>
</ul>

<p>When you see wxExecute(TRUE) or wxExecute(FALSE) you have absolutely no idea what does it
mean. Even if you know (from reading the documentation) that the parameter
specifies whether the program execution should be synchronous or not, you still
don't know which one is which: TRUE
and FALSE here are just the &quot;bare numbers&quot;
which don't help the person reading the code to understand what do they stand
for. The solution is the same for the other bare numbers: replace them with the
symbolic constants. Indeed, when you see wxExecute(wxEXEC_ASYNC) you have no troubles understanding it on
the first reading nor is there any danger of confusing the sync and async
calls. </p>

<ul>
 <ol start=8 type=1>
  <ol start=2 type=1>
   <li><i>Inextensible:</i></li>
  </ol>
 </ol>
</ul>

<p>Suppose now that you
want to add another parameter to wxExecute(), for example whether a new console window should be opened, you have
to add another parameter. And if it is bool as well you end up with such clear
and expressible perls as wxExecute(TRUE, FALSE). </p>

<p>The solution is
simple: replace bool with int and add some flags with symbolic names.
This solves both problems at once: not only you can avoid adding a new parameter
to the function (which is especially important if it already has two or three
of them) but also a call such as wxExecute(wxEXEC_ASYNC | wxEXEC_NEW_CONSOLE) is as readable as it gets. </p>

<p>The only situations
in which bool parameters may be used are those where theur meaning is
immediately clear from the function purpose, for example it is not unreasonable
to have a Show(bool
show = TRUE) function which
either shows or hides something. But in vast majority of the cases, the meaning
is not immediately clear to the reader and using the symbolic flag constants is
a better alternative. </p>

<ul>
 <ol start=9 type=1>
  <li><a
      name="no_extra_semicolon"></a>Don't
      use extra semi-colons on top level </li>
 </ol>
</ul>

<p>Some compilers don't
pay any attention to extra semicolons on top level, as in </p>

<p> 
class Foo { };;</p>

<p>while others
complain loudly about it. Of course, you would rarely put 2 semicolons
yourself, but it may happen if you're using a macro (IMPLEMENT_something, for example) which already has a ';'
inside and put another one after it. </p>

<p>&nbsp;</p>

<ul>
 <li>Unix/DOS differences </li>
</ul>

<p>Two operating
systems supported by wxWidgets right now are (different flavours of) Unix and
Windows 3.1/95/NT (although Mac, OS/2 and other ports exist/are being developed
as well). The main differences between
them are summarized here. </p>

<ul>
 <ol start=1 type=1>
  <li><a
      name="use_cpp_ext"></a>Use
      .cpp for C++ source file extension </li>
 </ol>
</ul>

<p>There is, unfortunately,
no standard extension for C++ source files. Different people use .C, .cc, .cpp,
.cxx, .c++ and probably several others I forgot. Some compilers don't care
about extension, but there are also other ones which can't be made to compile
any file with &quot;wrong&quot; extension. Such compilers are very common in
DOS/Windows land, that's why the .cpp extension is the least likely to cause
any problems -- it's the standard one under DOS and will probably be accepted
by any Unix compiler as well (any counter examples?). The extension for the header files is .h. </p>

<ul>
 <ol start=2 type=1>
  <li><a
      name="no_backslash"></a>Don't
      use backslash ('\\') in #includes </li>
 </ol>
</ul>

<p>Although it's too
silly to mention, please don't use backslashes in #include preprocessor statement. Even not all
Windows compilers accept it, without speaking about all other ones. </p>

<ul>
 <ol start=3 type=1>
  <li><a
      name="no_carriagereturn"></a>Avoid
      carriage returns in cross-platform code </li>
 </ol>
</ul>

<p>This problem will
hopefully not arise at all, with CVS taking care of this stuff, however it's
perhaps not useless to remember that many Unix compilers (including, but not
limited to, gcc) don't accept carriage returns (= = '\r') in C/C++ code. </p>

<ul>
 <ol start=4 type=1>
  <li><a
      name="no_caps_in_filenames"></a>Use
      only lower case filenames </li>
 </ol>
</ul>

<p>DOS/Windows 3.1
isn't case sensitive, Windows 95/NT are case preserving, but not case
sensitive. To avoid all kinds of problems with compiling under Unix (or any
other fully case-sensitive OS), please use only lower case letters in the
filenames. </p>

<ul>
 <ol start=5 type=1>
  <li><a
      name="no_incomplete_files"></a>Terminate
      the files with a new-line </li>
 </ol>
</ul>

<p>While DOS/Windows
compilers don't seem to mind, their Unix counterparts don't like files without
terminating new-line. Such files also give a warning message when loaded to vim
(the Unix programmer's editor of choice :-)), so please think about terminating
the last line. </p>

<ul>
 <ol start=6 type=1>
  <li><a
      name="no_case_only_diff"></a>Avoid
      globals differing by case only </li>
 </ol>
</ul>

<p>The linker on VMS is
case-insensitive. Therefore all external variables and functions which differ
only in case are not recognized by the linker as different, so all externals
should differ in more than the case only: i.e. GetId is the same as GetID. </p>

<p>&nbsp;</p>

<ul>
 <li>Style choices </li>
</ul>

<p>All wxWidgets
specific style guidelines are specified in the next section, here are the
choices which are not completely arbitrary, but have some deeper and not
wxWidgets-specific meaning. </p>

<ul>
 <ol start=1 type=1>
  <li><a
      name="naming_conv"></a>Naming
      conventions: use m_ for members </li>
 </ol>
</ul>

<p>We all know how
important it is to write readable code. One of the first steps in this
direction is the choice of naming convention. It may be quite vague or strictly
define the names of all the variables and function in the program, however it
surely must somehow allow the reader to distinguish between variable and
functions and local variables and member variables from the first glance. </p>

<p>The first
requirement is commonly respected, but for some strange reasons, the second
isn't, even if it's much more important because, after all, the immediate
context usually allows you to distinguish a variable from a function in C/C++
code. On the other hand, you <i>cannot</i> say what x in the following code fragment is: </p>

<p> 
void Foo::Bar(int x_)</p>

<p> 
{</p>

<p>   
...</p>

<p>&nbsp;</p>

<p>   
x = x_;</p>

<p>&nbsp;</p>

<p>   
...</p>

<p> 
}</p>

<p>It might be either a
local variable (unluckily the function is too long so you don't see the
variable declarations when you look at x = x_ line), a member variable or a global
variable -- you have no way of knowing. </p>

<p>The wxWidgets naming
convention gives you, the reader of the code, much more information about x. In the code above you know that it's a
local variable because: </p>

<ul>
 <ol start=1 type=1>
  <ol start=1 type=1>
   <li>global variables are always prefixed
       with g_ </li>
   <li>member variables are always prefixed
       with m_ </li>
   <li>static variables are always prefixed
       with s_ </li>
  </ol>
 </ol>
</ul>

<p>Examples: </p>

<p> 
extern int g_x;</p>

<p>&nbsp;</p>

<p> 
void Bar()</p>

<p> 
{</p>

<p>   
int x;</p>

<p> 
}</p>

<p>&nbsp;</p>

<p> 
class Foo {</p>

<p>   
public:</p>

<p>     
void SetX(int x) { m_x = x; }</p>

<p>   
private:</p>

<p>     
int m_x;</p>

<p> 
};</p>

<p>As you see, it also
solves once and for all the old C++ programmer's question: how to call SetX() parameter? The answer is simple: just call
it x because there is no ambiguity with Foo::m_x. </p>

<p>The prefixes can be
combined to give ms_ and gs_ for static member (a.k.a. class) variables
and static global variables. </p>

<p>The convention is,
of course, completely worthless if it is not followed: nothing like being sure
that x is a local variable in the code fragment
above and discovering later the following lines in the header: </p>

<p> 
class Foo {</p>

<p>   
...</p>

<p>   
int x;</p>

<p> 
};</p>

<p>Please do use these prefixes,
they make your code much easier to read. Also please notice that it has nothing
to do with the so-called <i>Hungarian notation</i> which is used in wxMSW part
of wxWidgets code and which encodes the <i>type</i> of the variable in its name
-- it is actually quite useful in C, but has little or no sense in C++. </p>

<ul>
 <ol start=2 type=1>
  <li><a
      name="no_void_param"></a>Don't
      use void
      for functions without arguments </li>
 </ol>
</ul>

<p>In ANSI C, void Foo() takes an arbitrary number of arbitrarily
typed arguments (although the form void Foo(...) is preferred) and void Foo(void) doesn't take any arguments. In C++,
however, the situation is different and both declarations are completely
equivalent. As there is no need to write void in this situation, let's not write it -- it can only
be confusing and create an impression that it really means something when it's
not at all the case. </p>

<ul>
 <ol start=3 type=1>
  <li><a
      name="no_const_int"></a>Don't
      use const
      for non pointer/reference arguments </li>
 </ol>
</ul>

<p>In both C and C++ an
argument passed by value cannot be modified -- or, more precisely, if it is
modified in the called function, only the local copy is really changed, not the
caller's variable. So, semantically speaking, there is no difference between void Foo(int) and void Foo(const int). However, the const keyword is confusing here, adds nothing to
the code and even cannot be removed if Foo() is virtual and overridden (because the
names are mangled differently). So, <i>for arguments passed by value</i> you
shouldn't use const. </p>

<p>Of course, it
doesn't apply to functions such as void PrintMessage(const char *text) where const is mandatory. </p>

<ul>
 <ol start=4 type=1>
  <li><a
      name="null_not_zero"></a>Use NULL rather than 0 </li>
 </ol>
</ul>

<p>We have chosen to
use the standard NULL macro in
the expressions involving the pointers instead of just the constant 0. Although both are perfectly equivalent in
this context, we feel that using NULL
provides better readability and stands out better. </p>

<p>A related advice is
to use '\0' instead of 0 in the expressions involving chars. </p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<hr size=2 width="100%" align=center>

</a></div>

<p class=MsoNormal>Please send any
comments to <a
href="mailto:zeitlin@dptmaths.ens-cachan.fr">Vadim Zeitlin</a>.</p>

</div>

</body>

</html>
