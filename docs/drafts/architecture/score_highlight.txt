Highligt is done by direct DC drawing. This makes the display dirty.
A posible partial solution is to repaint from bitmap instead of painting again
using black color. For full solution probably I will have to move to
double buffering.


Attempt 1: Saving the AGGDrawer buffer
---------------------------------------

1. Save AGGDrawer buffer:
        + Need to inform GraphicManager that highlight will start.

2. For each object:
    1. Restore AGGDrawer buffer from saved copy
    2. Paint object using AGGDrawer
    3. Display new bitmap

3. Restore AGGDrawer buffer when playback finished.
        - Need to inform GraphicManager that highlight has finished.
        
        
Problem:
    Previous algorithm assumes than an object's image is restored before highlighting
    the next one. And this is not true; for example, when playing a whole note a several 
    eighth notes, the whole note must remain highlighted.
    
    
Attemp 2: using wxDragImage concept
------------------------------------

event visual ON:
    1. create a wxDragImage for the object to highlight and display it:
        - need to determine the total rectangle occupied by object
        - need to create the dragImage using AGG
    
event visual OFF:
    2. Hide the wxDragImage and delete it.
    
    
Reflections:
    The idea of dragImage is that of an layered small bitmap over the AGGDrawer buffer.
    Implementing it requires:
    - To be able to pre-compute the size (rectangle) occupied by an object's drawn.
    - To draw on the layered bitmap using AGG.
    So, it is basically returning to algorithm 1 but adding complexity to allow for
    multi-layered bitmaps:
    
    
1. Save AGGDrawer buffer:
        + Need to inform GraphicManager that highlight will start.

2. For each object:
    - event visual ON:
        1. Create a new empty AGG buffer
            - Triggered by Drawer::StartObjectDraw()
        2. Draw object on it
        3. Clip AGG buffer to painted rectangle and return it (layer bitmap)
        4. Save layer bitmap and display in screen (offscreen bitmap not changed)
            - 3 & 4 triggered by Drawer::EndObjectDraw()

    - event visual OFF:
        1. Delete layer bitmap from highlighted objects' list
        2. Refresh screen using offscreen bitmap
        3. overlay layer bitmaps of all highlighted objects' list

3. event RemoveAllHighlight:
        1. Delete all layer bitmaps from highlighted objects' list
        2. Refresh screen using offscreen bitmap
        
        
Reflections:
  - Bug: Current draw method, invoking DrawObject() is not addecuate as DrawObject will draw
    not only the note but also all related auxObj, such as accidentals, texts, ties, slurs,
    etc., and only some of them must be highlighted (accidentals?, ties?) ==> leave
    this issue for later.
    
  - Creating or copying the full AGG buffer for each note to highlight can be very expensive.
    If we new in advance the size (rectangle) than the object will occupy, we will save
    memory (allocating just the required bitmap) and time (whole buffer copying, later
    clipping). This can be measured at measurement phase. 
    

Let's assume than the the size (rectangle) than the object will occupy when highlighted
has been computed at measurement phase:
     
1. Save AGGDrawer buffer:
        + Need to inform GraphicManager that highlight will start.

2. For each object:
    - event visual ON:
        1. Create a new empty AGG buffer with the size of the object
        2. Draw object on it
        2. Save bitmap in highlighted object's list
        3. Update screen rectangle with this transparent bitmap (XOR)

    - event visual OFF:
        2. Update screen rectangle with highlighted object bitmap (XOR)
        1. Delete bitmap from highlighted objects' list

3. event RemoveAllHighlight:
        2. Update screen rectangles with all highlighted object's bitmaps (XOR)
        1. Delete bitmaps from highlighted objects' list
        
      
Reflections:
    The highlight events are only generated by SoundManager, when playing a score. And        
    highlight is currently, only for notes and rests. Therefore, we can simplify the 
    highlight issue by just highlighting the noteheads. In this way, the drag image size
    (and perhaps the drag image bitmap) can be used for higlighting.
    
    Also, as noteheads and rests are rendered using the font, AGG drawer is not
    necessary because texts is already anti-aliased. So it would be posible to return
    to the original idea of using dragImage:
    
    
event visual ON:
    1. create a wxDragImage for the object to highlight and display it:
        + need to determine the total rectangle occupied by object ==> Done. The
            current size used for dragging
        + need to create the dragImage using AGG ==> No loger needed as
            text is already anti-aliased
    
event visual OFF:
    2. Hide the wxDragImage and delete it.
    
    
Reflections:
    This can be simplified even more: current method works OK for text rendered objects.
    The problem is in lines and other program generated shapes. If we only highlight
    noteheads and rests we could use all current highlight methods if we add a flag
    to Draw() method to skip rendering other things.


OK. Implemented in this way.
    
    
    
