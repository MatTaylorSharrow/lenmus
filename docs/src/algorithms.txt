//--------------------------------------------------------------------------------------
//    LenMus Phonascus: The teacher of music
//    Copyright (c) 2002-2006 Cecilio Salmeron
//
//    This program is free software; you can redistribute it and/or modify it under the 
//    terms of the GNU General Public License as published by the Free Software Foundation;
//    either version 2 of the License, or (at your option) any later version.
//
//    This program is distributed in the hope that it will be useful, but WITHOUT ANY 
//    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
//    PARTICULAR PURPOSE.  See the GNU General Public License for more details.
//
//    You should have received a copy of the GNU General Public License along with this 
//    program; if not, write to the Free Software Foundation, Inc., 51 Franklin Street, 
//    Fifth Floor, Boston, MA  02110-1301, USA.
//
//    For any comment, suggestion or feature request, please contact the manager of 
//    the project at cecilios@users.sourceforge.net
//
//-------------------------------------------------------------------------------------
/*! @page algorithms        Notes on algorithms


@section xml_measure_atributes Problem of XML Measure attributes
<!-- ============================================================================ -->

  - Problem with TimeSignatures and KeySignatures in XML: Clef and signatures are
    treated as attributes of the measure, not as objects. Therefore, ordering (clef, tonal
    key, time signature) is not important for XML and there are examples in wich this
    information is encoded in reversed orders (i.e. time signature, clef). This causes 
    problems as LenMus expects that this objects are defined in the right order.
    
    - This is an example of divergence between internal representation and representation
    for a particular purpose (graphical model) that comes in support for the Guido
    approach of two steps generation: internal model --> graphical and sound models.
    
    - For now, a by pass solution must be found:
        - Time to deal with contexts?
        - Re-ordering in lmTimeposTable?
        - Re-ordering at XML parser objects creation?


@section algorithm_stems_in_beamed_groups Computation of stems for a beamed group
<!-- ============================================================================ -->
    Things to take into account:
        - The notes of a group can be in different staves (i.e. piano grand staff). 
        - In agroup stems can go in both directions.
        - For chords, only base note is in the beamed group. Beam computation can not
			take place until all the notes that form the chord has been added
		- There can be rests inside the group, therefore rests also have beaming information.
			That's why beaming information is defined in %lmNoteRest object and both
			constructors, Note and Rest, require beaming information.
  
	Algorithm

		As the notes/rest are being defined their x,y base position (the point near to the
	notehead) is computed. The y base position is exact but the x position is just a 
	preliminary provisional value. The stem height is a standard fixed value.
	When the score is going to been rendered, in measurement phase, the exact x base position
	of notes and rests is computed, but it is only at the end of mesuarement phase when this
	information is valid, because as space justification might alter the x position 
	previously computed in each Note object.
	
		Nevertheless, during the measurement phase, when in a Note object is detected that
	the note is the first one of a beamed group, the beam object is invoked (method
	ComputeStemsDirection) to do certain computations:
	- Fix stems direction. If one note has is stem direction forced (by a tie with a previous
		note, or by the user) this forces all the group stems to this direction.
	- Do a rough computation of stems heigh. This is necessary to set the Y position for
		rests inside the beamed group.
	In this computation, stems' length is not changed.
	
		Final trimming of stems' length is delayed to MakeUp phase because it is not
    posible to adjust lenghts until the x position of the notes is finally established, and
    this takes place AFTER the measurement phase, once the lines are justified.
	In MakeUp phase, the stems' lenght are computed by the Beam object by invoking method
	TrimStems from the first note of the beam.



@section algorithm_ties Computation of ties
<!-- ============================================================================ -->
    Things to take into account:
        - The tied notes can be in different systems. This forces to draw two ties: one 
			from the first note to the end of the first system and a second tie from the
			begining of the second system to tied note.
		- If any of the notes is dragged, the ties must move accordingly.
  
	Algorithm

		At Make up phase, in each Note object:
	- If the note is the end of a tie, compute tie end point and store it in the
		Tie object (method StoreEndPoint is invoked just to store the computed 
		data). Additional information is stored:
			- To compute the start of the extra tie arch in case the tie must be splitted,
				also paper x left margin is stored.
			- To determine if tie must be spplited due to system change, also paper
			y base is stored. 

	- If the note is the start of a tie, compute tie start point and store it in the
		Tie object (method SetStartPoint is invoked just to store the computed 
		data). Also, tie position is determined by note stem direction.
			Additional information is stored:
			- Tie position (under or over the noteheads) is determined by the start note
			stem direction.
			- To compute the end of the extra tie arch in case the tie must be splitted,
				also paper x right margin is stored.
			- To determine if tie must be spplited due to system change, also paper
				y base is stored. 
  
		All this must be done at make up because notes's x position is not fixed until the
    end of the measurement phase, after the line justification process.
    
		When Tie method StoreEndPoint is invoked, it is computed if the tie
	has to be splitted by comparing the y paper base pos of the start and end notes. If
	it is not the same, it implies that the notes are in different systems and, therefore,
	the tie must be splitted.


@section algorithm_chords Renderization of chords
<!-- ============================================================================ -->

	1. compute which noteheads go shifted to right
	
	Loop to render accidentals:
	2. Set x pos to start of chord x pos
	3. Render accidental. If collision with other accidental:
		Do while collision:
			set x pos after collisioning accidental
			Render accidental
			test if collision
		end do
		
	Loop to render noteheads:
	4. set x pos to start of chord x pos
	5. Render notehead. If collision with an accidental:
		Do while collision:
			set x pos after collisioning accidental
			Render notehead
			test if collision
		end do

	Loop to shift noteheads to have a common anchor line:
	6. Compute common anchor line as the max anchor line position
	7. Add a shift to each note so that its anchor line become the max anchor line
	
	
	
	Current note renderization algorithm
	--------------------------------------
	
	1. Render accidental at xPaperPos. To control its position there is a variable in lmNote
		(m_alterPos) but is never initialized and not used. I think it is useless.
	2. Advance xPos to after accidental (it includes the accidental afterspace). This position
		is saved as anchor position.
	3. Render notehead. It is rendered at that position. There is nothing to include more
		space after the accidental. 
	4. Advance xPos by adding notehead width
	5. Draw dots
	6. Add note afterspace and compute total width 
	7. To draw the stem, the pen is repositioned at notehead.x or 
		notehead.x + notehead.width, depending on stem direction.
		
		
		
		
		
@section contexts  Context for notes
<!-- ============================================================================ -->

	After creating a new barline (in method VStaff::AddBarline) method lmVStaff::ResetContexts
	is invoked to reset the context if it was modified by accidentals in notes, and leave
	a new context with only the key signature accidentals.
	
		lmVStaff::ResetContexts:
			Verify if current context is just the key signature accidentals. If not,
			create a new context.
			This method is invoked after a barline to reset the context if it was modified 
			by accidentals in notes


*/