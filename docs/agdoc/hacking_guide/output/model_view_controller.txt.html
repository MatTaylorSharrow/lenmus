
<html>
<head>
<title>The LenMus Model-View-Controller architecture</title>
<meta http-equiv="Content-Type" content="text/html" />
<link rel="stylesheet" type="text/css" href="screen3.css" type="text/css" />
</head>
<body>




<h1 class='article'>The LenMus Model-View-Controller architecture
</h1>

<p class="copyright">
LenMus project (http://www.lenmus.org/)<br />
<a href="#legal_notice">GNU Free Documentation License</a>
</p>


<a name="TOC">&nbsp;</a><p class='toc'>Table of contents</p><p><a class='toc_level1' href='index.txt.html'>Hacking guide main TOC</a></p>
    <a class='toc_level1' href="#toc0001">The Model-View-Controller architecture</a>
    <a class='toc_level1' href="#toc0002">Where to place the controller</a>
    <a class='toc_level1' href="#toc0003">The wxWidgets framework</a>
    <a class='toc_level1' href="#toc0004">Basic LenMus classes for the MVC model</a>
    <a class='toc_level1' href="#toc0005">Special needs in LenMus program</a>
        <a class='toc_level2' href="#toc0006">lmMainFrame: using a tabbed document interface (TDI)</a>
        <a class='toc_level2' href="#toc0007">lmDocManager: More ways to create a document</a>
        <a class='toc_level2' href="#toc0008">The ToolBox</a>
        <a class='toc_level2' href="#toc0009">Score editor 'modes'</a>
        <a class='toc_level2' href="#toc0010">ToolBox customizations</a>
        <a class='toc_level2' href="#toc0011">Score processors</a>
        <a class='toc_level2' href="#toc0012">Exercises using the full score editor</a>
        <a class='toc_level2' href="#toc0013">Reloading an exercise score</a>
    <a class='toc_level1' href="#toc0014">Dealing with all these needs</a>
        <a class='toc_level2' href="#toc0015">Creating the document, the view/controller. First renderization of lmScoreView</a>
    <a class='toc_level1' href="#toc0016">Switching modes when viewing another score</a>
    <a class='toc_level1' href="#toc0017">Continue in 'exercise mode' after reloading an exercise score</a>
    <a class='toc_level1' href="#toc0018">How is an score saved?</a>
    <a class='toc_level1' href="#toc0019">Commands to change an score</a>
    <a class='toc_level1' href="#toc0020">Things To Do</a>







<h2 class='article'><a name="toc0001"></a>The Model-View-Controller architecture</h2>


<p class='justified'>The Model-View-Controller (MVC) architecture is a well known design pattern that uses three kinds of objects:</p>

<p class='justified'><div class="orderedlist"><ol type="1">
<li>The Model is the document object, that is, encapsulates the domain-specific representation of the information on which the application operates, as well as its functionality (domain logic).</li>
<li>The View is its screen representation. Obtains data from the model and presents it to the user.</li>
<li>The controller defines the way the user interface reacts to user input. Receives and translates input to requests on the model or the view.</li></ol><div></p>

<p class='justified'>MVC decouples these parts to reduce the complexity in architectural design and to increase flexibility and reuse. The control flow generally works as follows:</p>

<p class='justified'><div class="orderedlist"><ol type="1">
<li>The user interacts with the GUI in some way (i.e., presses a button).</li>
<li>The controller handles the input events from the user interface, and accesses the model, possibly updating it in a way appropriate to the user&#039;s action.</li>
<li>The view uses the model (indirectly) to generate an appropriate user interface. The view gets its own data from the model. The model has no direct knowledge of the view. </li>
<li>The user interface waits for further user interactions, which begins the cycle anew.</li></ol><div></p>
    
<p class='justified'>The views and the model are coupled by establishing a subscribe/notify protocol between them.</p>

<p class='justified'>A view must ensure that its appearance reflects the state of the model. Whenever the model&#039;s data changes, the model notifies views that depend on it. In response, each view gets an opportunity to update itself. This approach lets you attach multiple views to a model to provide different presentations. You can also create new views for a model without rewriting it.</p>




<h2 class='article'><a name="toc0002"></a>Where to place the controller</h2>


<p class='justified'>LenMus follows the traditional Model-View-Controller design pattern. It is modelled by three abstract classes:</p>

<p class='justified'><div class="itemizedlist"><ul type="disc">
<li><b>lmView</b> (wxView) <br />
      Abstract class from which all views must derive. Related to it there must exist a frame class (derived from <span class="kw1">wxFrame</span>) that represents the frame window that frames the visual representation of the view. And a canvas window (derived from <span class="kw1">wxWindow</span>) that represents the window on which the view is rendered.</li></ul><div></p>
      
<p class='justified'><div class="itemizedlist"><ul type="disc">
<li><b>lmController</b> (wxWindow) <br />
      Abstract class from which all controllers must derive. It is defined in file <span class="kw1">app/ScoreCanvas.h</span>.</li></ul><div></p>

<p class='justified'><div class="itemizedlist"><ul type="disc">
<li><b>wxDocument</b> <br />
      wxWidgets abstract class from which all models (documents) must derive</li></ul><div></p>

<p class='justified'>User interacts with the GUI: the score canvas, any of its containers (<span class="kw1">lmEditFrame</span>, <span class="kw1">lmMainFrame</span>), other windows on the GUI (<span class="kw1">lmToolsBox</span>), hardware devices (keyboard, MIDI devices), mouse interaction with the GUI (menubars, toolbars, tools box, etc), mouse interaction with the view, etc.</p>

<p class='justified'>All events coming from all these sources should be send to a single point: the controller. But the problem is where to place it. In the view? In the canvas? In a specific controller class?</p>

<p class='justified'>By analysing how user events are processed, we can see that interaction (except mouse interaction with the view) can be managed by a an external controller who will receive all events. For mouse interaction with the view it is better to deal with it in the view, since only the view can give meaning to the interaction, and get information about the affected objects and the type of interaction. Once we have this information two strategies are possible:</p>
    
<p class='justified'><div class="orderedlist"><ol type="1">
<li>The view sends a command to the CommanProcessor, or</li>
<li>The view asks the controller to send the command.</li></ol><div></p>
    
<p class='justified'>The first alternative leads to the combined ViewController class. Therefore, the second alternative is better as it is up to the particular controller instance to process the command (by sending it) or to ignore it.</p>

<p class='justified'>Now the question is: create a controller class or use the canvas as controller? I experimented by creating a specific controller class but after creating it I realized that:</p>

<p class='justified'><div class="itemizedlist"><ul type="disc">
<li>All events from the canvas will have to be redirected to the controller.</li>
<li>The controller needs an event handler but, as it is not a window, it doesn&#039;t have one. So to give a handler it will have to be derived from <span class="kw1">wxEvtHandler</span>.</li>
<li>The canvas has nothing to do but to redirect events to the controller. Moreover, the canvas is a window and therefore, has an event controller without having to define it and to place it in the handlers chain.</li>
<li>Creating an specific controller class separated from the canvas means another class to create an manage.</li></ul><div></p>
    
<p class='justified'>From this list my conclusion was to use the canvas as controller. Therefore, in lenmus program the controller plays an additional role: it is the window used by the view to render the document.</p>
   
   


<h2 class='article'><a name="toc0003"></a>The wxWidgets framework</h2>



<p class='justified'>The <span class="kw1">wxWidgets</span> framework does not implement the MVC model but the Document-View (doc/view) model. The doc/view model is similar to the MVC model, where the Document is equivalent to the Model and the View and the Controller are merged into a single object: the View. wxWidgets has several classes to support the doc/view model. These are the main ones:</p>

<p class='justified'><div class="itemizedlist"><ul type="disc">
<li><span class="kw1">wxDocument</span> <br />
    This class represents the&#039; document&#039;. Models an application&#039;s file-based data. A range of menu commands <span class="larger">&#151;</span> such as open, save, save as <span class="larger">&#151;</span> are supported automatically. <span class="kw1">wxDocument</span> is a class derived from wxEvtHandler, and it has information about the doc/view relationship (represented by <span class="kw1">wxDocTemplate</span>) and knows about all the views displaying that document.</li></ul><div></p>

<p class='justified'><div class="itemizedlist"><ul type="disc">
<li><span class="kw1">wxView</span> <br />
    The &#039;View-Controller&#039;. Models the viewing and editing component of an application&#039;s file-based data.</li></ul><div></p>
    
<p class='justified'><div class="itemizedlist"><ul type="disc">
<li><span class="kw1">wxDocManager</span> <br />
    All management of documents and views is controlled by an object (singleton) of class <span class="kw1">wxDocManager</span>. It is an even handler (derives from <span class="kw1">wxEvtHandler</span>) and deals with the most common events and commands related to documents: open, new, save, print, etc. The <span class="kw1">wxDocManager</span> is created and owned by the application object (in LenMus, <span class="kw1">lmTheApp</span>), and it is passed to the main frame as a parameter when the main frame is created. <span class="kw1">wxDocManager</span> only maintains information about all open documents and about the current selected view.</li></ul><div></p>

<p class='justified'><div class="itemizedlist"><ul type="disc">
<li><span class="kw1">wxDocTemplate</span> <br />
    It is mainly information describing the classes to use, for the document and its view, when creating a new document. As <span class="kw1">wxDocManager</span>, <span class="kw1">wxDocTemplate</span> is also created and owned by the application object (in LenMus, <span class="kw1">lmTheApp</span>).  <span class="kw1">wxDocTemplate</span>  constructor receives the <span class="kw1">wxDocManager</span> as parameter and the constructor associates the created template to the doc manager (by invoking <span class="kw1">wxDocManager::AssociateTemplate(this)</span>).</li></ul><div></p>
    
<p class='justified'><div class="itemizedlist"><ul type="disc">
<li><span class="kw1">wxDocMDIParentFrame</span> <br />
    This class provides a default top-level frame for applications using the document/view framework. This class can only be used for applications in which all displayed document windows are constrained inside a single parent window. This model is known as &#039;Multiple Document Interface&#039; (MDI).</li></ul><div></p>
   
<p class='justified'>I started by trying to use all these wxWidgets classes to implement the MVC model. The first problem I had was how to separate the controller from the view. Later, I found other problems that I also describe in these documentation. I will jump from one issue to another, trying to describe the code, the problems found and the implemented solutions.</p>




<h2 class='article'><a name="toc0004"></a>Basic LenMus classes for the MVC model</h2>


<p class='justified'>For score edition, the following specific classes are created:</p>

<p class='justified'><div class="itemizedlist"><ul type="disc">
<li>The View is <b>lmScoreView</b> (derived from <span class="kw1">lmView</span>). To render the view two more classes are involved:</li>
<div class="itemizedlist"><ul type="disc">
<li><span class="kw1">lmEditFrame</span> (derives from <span class="kw1">lmTDIChildFrame</span>, and this in turn from <span class="kw1">wxPanel</span>). It is the frame on which we are going to place all windows an controls to render the view. There are several controls (scroll bars and rulers) and a window (the lmScoreCanvas).</li>
<li>lmScoreCanvas (derives from <span class="kw1">lmController</span>). It is the window on which the score is going to be rendered.</li></ul><div></ul><div></p>
            
<p class='justified'><div class="itemizedlist"><ul type="disc">
<li>The Model is <b>lmDocument</b>. It contains the score to be rendered and a few additional data.</li></ul><div></p>
    
<p class='justified'><div class="itemizedlist"><ul type="disc">
<li>The Controller is <b>lmScoreCanvas</b>. Derives from <span class="kw1">lmController</span>. All interaction with the document takes place by issuing &#039;commands&#039; modelled by class <span class="kw1">lmScoreCommand</span> (derives from <span class="kw1">wxCommand</span>).</li></ul><div></p>


<p class='justified'>For exercises, the involved classes are:</p>

<p class='justified'><div class="itemizedlist"><ul type="disc">
<li>The View is <b>lmScoreAuxCtrol</b>: A window on which a music score is rendered. No direct interaction with the score is allowed (except Play/Stop/Zoom), that is, it is just a display control.</li></ul><div></p>
    
<p class='justified'><div class="itemizedlist"><ul type="disc">
<li>The Model is <b>lmScore</b>: the score to be rendered.</li></ul><div></p>
    
<p class='justified'><div class="itemizedlist"><ul type="disc">
<li>User interaction takes place through the <span class="kw1">lmHtmlWindow</span> (the container of the <span class="kw1">lmScoreAuxCtrol</span>), so the controller is in it or in its containers classes (<span class="kw1">lmBookFrame</span>, <span class="kw1">lmTextBookContrller</span>).</li></ul><div></p>




<h2 class='article'><a name="toc0005"></a>Special needs in LenMus program</h2>



<h3 class='article'><a name="toc0006"></a>lmMainFrame: using a tabbed document interface (TDI)</h3>



<p class='justified'>Class <span class="kw1">lmMainFrame</span> represents the main frame of the LenMus application. It manages all common controls on the GUI (menu, toolbar, status bar) as well as all application windows (scores to edit, open eBook, etc).</p>

<p class='justified'>In the <span class="kw1">wxWidgets</span> framework, the main frame normally derives from <span class="kw1">wxDocMDIParentFrame</span>. As commented, <span class="kw1">wxDocMDIParentFrame</span> only supports the Multiple Document Interface (MDI) model. But this model is obsolete and I preferred a tabbed document interface (TDI). Therefore, it was necessary to replace the standard base class <span class="kw1">wxDocMDIParentFrame</span>  by something specific for the LenMus program. This new class is <span class="kw1">lmDocTDIParentFrame</span>.</p>

<p class='justified'>The TDI model involves tree classes: the main frame is modelled by a &#039;Parent Frame&#039; and it contains a &#039;Client Window&#039; on which &#039;Child Frame&#039; windows (one for each open document) are displayed.</p>

<p class='justified'>In LenMus, the &#039;Client Window&#039; is class <span class="kw1">lmTDIClientWindow</span> derived from <span class="kw1">wxAuiNotebook</span>. The &#039;Parent Frame&#039; is class <span class="kw1">lmTDIParentFrame</span> derived from <span class="kw1">wxFrame</span>. And the &#039;Child Frame&#039;, represented by a tab in the notebook, is class <span class="kw1">lmTDIChildFrame</span> derived from <span class="kw1">wxPanel</span>.</p>

<p class='justified'>To add support for the doc/view model (or the Model-View-Controller model), the main frame needs additional methods. Therefore, a different class, named <span class="kw1">lmDocTDIParentFrame</span>, was derived from <span class="kw1">lmTDIParentFrame</span> for the doc/view model, and requires a <span class="kw1">wxDocManager</span> as parameter.</p>

<p class='justified'>In summary: <span class="kw1">lmMainFrame</span> is a <span class="kw1">lmDocTDIParentFrame</span>. To display children windows it uses a <span class="kw1">wxAuiNotebook</span>. Each tab of this notebook can be:
<div class="itemizedlist"><ul type="disc">
<li>A view in the MVC model (i.e. score to edit) (class <span class="kw1">lmDocTDIChildFrame</span>)</li>
<li>A independent window (i.e. eBook, Welcome page) (class <span class="kw1">lmTDIChildFrame</span>)</li></ul><div></p>

<p class='justified'>Class <span class="kw1">lmMainFrame</span> is in file <span class="kw1">app/MainFrame.h</span>. All other classes to implement the TDI interface are in <span class="kw1">mdi/ParentFrame.h</span>, <span class="kw1">mdi/ClientWindow.h</span>, <span class="kw1">mdi/ChildFrame.h</span>, and <span class="kw1">mdi/DocViewMDI.h</span>.</p>




<h3 class='article'><a name="toc0007"></a>lmDocManager: More ways to create a document</h3>



<p class='justified'>In the wxWidgets doc/view architecture all management of documents and views is controlled by an object of class <span class="kw1">wxDocManager</span>. It deals with the most common events and commands related to documents: open, new, save, print, etc.</p>

<p class='justified'>In the standard wxWidgets framework behaviour there are two possible methods to create a new document:
<div class="itemizedlist"><ul type="disc">
<li>method <span class="kw1">wxDocument::OnNewDocument()</span> is invoked to create a new empty score.</li>
<li>method <span class="kw1">wxDocument::OnOpenDocument()</span> is invoked to open an existing file containing the document.</li></ul><div></p>
 
<p class='justified'>But in LenMus program, we don&#039;t need method <span class="kw1">wxDocument::OnNewDocument()</span> because we will never create an empty document. The &#039;Score New&#039; option will open a &#039;wizard&#039; for page layout, and it will create an score with some content. Therefore, an empty score will never be created.</p>

<p class='justified'>And method <span class="kw1">wxDocument::OnOpenDocument()</span> (create a document by loading its content from an existing file) is not enough, as we need the following possibilities:</p>

<p class='justified'><div class="itemizedlist"><ul type="disc">
<li>Open score (LDP file)</li>
<li>Import score (MusicXML file)</li>
<li>Open an score created internally, by program, and not saved yet to file (for example, a new score created with the wizard, or an score created by an exercise).</li></ul><div></p>
 
 
<p class='justified'>To deal with these needs I have created a class (<span class="kw1">lmDocManager</span>) that derives and replaces <span class="kw1">wxDocManager</span>.</p> 

<p class='justified'><span class="kw1">lmDocManager</span> instance is created by and owned by the application object (<span class="kw1">lmTheApp</span>) as well as a <span class="kw1">wxDocTemplate</span> object. The <span class="kw1">wxDocTemplate</span> constructor receives the <span class="kw1">lmDocManager</span> as parameter and, internally, the constructor invokes:
</p><div class="informalexample"><pre class="programlisting">
m_documentManager-&gt;AssociateTemplate(this);
</pre></div>

<p class='justified'>Then, when the <span class="kw1">lmMainFrame</span> is created, the created <span class="kw1">lmDocManager</span> is passed to the main frame as a parameter in the constructor [ method <span class="kw1">lmTheApp::RecreateGUI()</span> ]</p>


<p class='justified'>lmDocManager takes also responsibility for orchestrating the creation, destruction and management of documents, and of its Views/Controllers.</p>





<h3 class='article'><a name="toc0008"></a>The ToolBox</h3>



<p class='justified'>All editor interaction with the score takes place through an <span class="kw1">lmController</span>. To define controller response to user commands, each <span class="kw1">lmController</span> could use any desired mechanism. A common way of doing this is by placing &#039;selection/option buttons&#039; on the main toolbar. Then user actions are interpreted based on toolbar selected options.</p>

<p class='justified'>But I don&#039;t like the idea of using the toolbar as it will end up with too many buttons and also it is more difficult to include controls (comboxes, radio buttons, help texts, etc.). So I decided to replace to toolbar with something better and more user-oriented. The toolbar normally ends up being a mess of buttons and controls with no apparent organization. And it takes too much space on top of the window. So, I decided to experiment with a palette of tools (the ToolBox) similar to that used in many CAD applications.</p>

<p class='justified'>As the tendency is to have wider screens (for multimedia) I though it would be better to place the toolbox on the left (right) side instead of on top, to give more space for the score. Anyway user should be able to choose a horizontal layout and top/bottom placement.</p>

<p class='justified'>So, to define controller response to user commands <span class="kw1">lmScoreCanvas</span> uses an associated ToolBox window (class <span class="kw1">lmToolBox</span>). This toolbox is built independly from the controller (<span class="kw1">lmScoreCanvas</span>) because it is going to be shared by all open <span class="kw1">lmEditFrames</span>. This main toolbox is owned and managed by <span class="kw1">lmMainFrame</span> and it is assigned to each open <span class="kw1">lmScoreCanvas</span>.</p>



<h3 class='article'><a name="toc0009"></a>Score editor 'modes'</h3>



<p class='justified'>For simple exercises there is no need for the user to interact with the score. For example, in an exercise to identify intervals, an score with an interval is presented to the user and the user just give her/his answer by clicking on a button.</p>

<p class='justified'>But for more advanced exercises it would be better to use the score editor to elaborate the answer. For example: dictation exercises, harmony exercises, etc.</p>

<p class='justified'>To customize the score editor for the needs of a particular exercise, the score editor must support &#039;editor modes&#039;. An &#039;editor mode&#039; is a set of restrictions and customizations to force the score editor to behave in a predefined way. For example, for four-parts harmony exercises, the editor could be restricted to use only four voices.</p>



<h3 class='article'><a name="toc0010"></a>ToolBox customizations</h3>



<p class='justified'>Using the score editor for exercises not only requires to support editor modes but also creates the need to customize the ToolBox (<span class="kw1">lmToolBox</span> class), for example to include special buttons and tools for the exercise.</p>

<p class='justified'>And this, in turns, requires specific customizations in the controller (<span class="kw1">lmScoreCanvas</span> class) to deal with the added tools.</p>

<p class='justified'>Implementation of this idea is just a question of using specialized controllers and of dynamically configuring the toolbox.</p>

<p class='justified'>As the main toolbox is shared between all open editor windows and as each one them could be in a different &#039;edition mode&#039;, the tool box should allow for multiple configurations.</p>



<h3 class='article'><a name="toc0011"></a>Score processors</h3>



<p class='justified'>There is a need for tools to process (or alter) a full score. For example, a tool to transpose a score, to add colours to voices, to make a piano reduction, etc. All these tools will derive from abstract class <span class="kw1">lmScoreProcessor</span>:  A class to process (or alter) a full score.</p>

<p class='justified'>It must have at least a method <span class="kw1">DoProcess()</span> to perform the specific processing it represents. And can issue edit commands.</p>

<p class='justified'>It can also display windows, for example, to ask for the control parameters required by the process to perform, or to show the result of the process.</p>

<p class='justified'>From the MVC point of view an score processor is part of the controller: receives user interaction (perhaps just the command &#039;do process&#039;) and issues commands to alter the score.</p>

<p class='justified'>See &#039;score processors&#039; (score_processors.txt) for details.</p>



<h3 class='article'><a name="toc0012"></a>Exercises using the full score editor</h3>



<p class='justified'>The idea is to use the score editor for exercises. The problem is presented as a score that the student has to modify. As the full editor is used, the student can save the score so that he/she can later continue the exercise.</p>

<p class='justified'>For checking user answer (the edited score) score and adding markup to display errors and suggestions an score processor could be used. This also has the advantage of a possible re-usability of the score checking code to build a general purpose tool, usable not only in exercises.</p>

<p class='justified'>Independently of the solution chosen to check for errors in the user exercise (the score) there is a need to add special tools (i.e. &#039;check for errors&#039; and &#039;remove all markup&#039; buttons) to the toolbox.</p>

<p class='justified'>Fore exercises using a score processor, the control flow is as follows:</p> 

<p class='justified'><div class="itemizedlist"><ul type="disc">
<li>an instance of the appropriate lmScoreProcessor is be created.</li>
<li>the lmScoreProcessor is requested to add a &#039;spacial tools&#039; panel to the ToolBox. It will include only the links supported by the lmScoreProcessor .</li>
<li>The score editor will be opened in appropriate mode, to edit the score.</li></ul><div></p>

<p class='justified'>lmFullEditorExercise *is not* a class derived from lmScoreProcessor. The score processor is part of the controller and, therefore, must not be created/owned by the exercise. This implies that the only links that will be added to the &#039;special tools&#039; panel in the ToolBox will be those required by the used lmScoreProcesor (i.e: &#039;Check solution&#039;). Any other required control (i.e, &#039;New problem&#039;, &#039;Exercise options&#039;) will be displayed on the eBook control.</p>



<h3 class='article'><a name="toc0013"></a>Reloading an exercise score</h3>



<p class='justified'>In order to be able to continue an exercise, we need to save meta-information with the score to know that the score was created by an exercise and what is the environment (toolbox customizations, editor mode, controller, etc) that must be setup to continue the exercise. Then, there is a need to orchestrate the creation of all that environment.</p>





<h2 class='article'><a name="toc0014"></a>Dealing with all these needs</h2>




<p class='justified'>To deal with all previously required needs the following approach was followed:</p>

<p class='justified'><div class="itemizedlist"><ul type="disc">
<li>the controller has now an associated ToolBox.</li>
<li>the toolbox could be customized for each open score.</li>
<li>the controller could be different for each open score.</li>
<li>one or more ScoreProcessors could modify an score.</li></ul><div></p>
        
<p class='justified'>Therefore, the controller is now composed by three classes:
<div class="itemizedlist"><ul type="disc">
<li><span class="kw1">lmScoreCanvas</span></li>
<li><span class="kw1">lmToolBox</span></li>
<li>Optionally, one or more instances of <span class="kw1">lmScoreProcessor</span>.</li></ul><div></p>
        
<p class='justified'>The standard <span class="kw1">wxWidgets</span> doc/view model uses:</p>
 
<p class='justified'><div class="itemizedlist"><ul type="disc">
<li><span class="kw1">wxDocManager</span> to manage the documents</li>
<li><span class="kw1">wxDocTemplate</span> for relating document types (different file extensions <span class="larger">&#151;</span> i.e. .txt, .drw) to different document/views.</li></ul><div></p>
    
<p class='justified'>Now, in LenMus I have defined:</p>

<p class='justified'><div class="itemizedlist"><ul type="disc">
<li><span class="kw1">lmDocManager</span> (derived from <span class="kw1">wxDocManager</span>) to extend base class for dealing with some needs:</li>
<div class="itemizedlist"><ul type="disc">
<li>Using MVC model instead of doc/view model</li>
<li>More ways to create a document.</li></ul><div></ul><div></p>
        
<p class='justified'><div class="itemizedlist"><ul type="disc">
<li><span class="kw1">lmEditorMode</span>, to be used instead <span class="kw1">wxDocTemplate</span>. <span class="kw1">lmEditorMode</span> provides additional information, such as the controller type, the required ToolBox customizations, and the optional Score processor to use.</li></ul><div></p>
 




<h3 class='article'><a name="toc0015"></a>Creating the document, the view/controller. First renderization of lmScoreView</h3>



<p class='justified'>The wxWidgets document/view architecture is used, and class <span class="kw1">wxDocManager</span> orchestrates the creation of the document and the view.</p>

<p class='justified'>The process starts when an event MENU_File_Open or MENU_File_New is created (i.e. via main menu &#039;file &gt; new&#039;  or &#039;file &gt; open&#039;).</p>

<p class='justified'>In response to these events, the associated method in lmMainFrame (i.e. lmMainFrame::OnFileOpen() ) is invoked. Then method m_pDocManager<span class="larger">&#8594;</span>OpenFile() is invoked. This method does two things:</p>

<p class='justified'><div class="itemizedlist"><ul type="disc">
<li>First it invokes lmDocManager::DoOpenDocument() to create the document. This
    first creates an empty lmDocument instace. Then it creates the lmScoreProcessor and informs the document [by invoking lmDocument::OnCreateCommandProcessor()]. Next, it asks the document to create the View/Controller by invoking lmDocument::OnCreate(). And, finally, it asks the document to load content in the document, by invoking either lmDocument::OnOpenDocument(path), lmDocument::OnNewDocumentWithContent(pScore) or lmDocument::OnImportDocument(path), depending on the specific way of creating the document.</li></ul><div></p>
    
<p class='justified'><div class="itemizedlist"><ul type="disc">
<li>Second, it asks the document to customize the controller. by invoking lmDocument::OnCustomizeController()</li></ul><div></p>

<p class='justified'>But this instace is empty, that is, it doesn&#039;t contains any score yet. Therefore, lmDocument member variable <span class="kw1">m_pScore</span> will be always <span class="kw1">NULL</span> at this point.</p>

<p class='justified'>Next, <span class="kw1">wxDocManager</span> proceeds to create the view. The invokation path for this complex but, finally, the following invocation takes place: <span class="kw1">wxDocTemplate::CreateView()</span>. This invokes the view constructor followed by an invocation to <span class="kw1">wxWiew::OnCreate()</span>.</p>

<p class='justified'>As wxWidgets doc/view framework doesn&#039;t create a controller class, I&#039;m putting the responsibility for creating the controller on the view. Method <span class="kw1">lmWiew::OnCreate()</span> creates a new <span class="kw1">lmEditFrame</span> (<span class="kw1">lmDocTDIChildFrame</span>) and its associated <span class="kw1">lmScoreCanvas</span> (the controller).</p> 

<p class='justified'>Creating the frame at this point has a drawback: the frame is created and painted. This causes and invokation to lmScoreView::OnSetFocus and when the canvas is going to be painted, to lmScoreView::RepaintScoreRectangle. But at this point the score is NULL and the method terminates doing nothing. Therefore, the canvas client area is not painted, and remains in grey color.</p>

<p class='justified'>Then the framework informs the document by invoking <span class="kw1">lmDocument::OnOpenDocument()</span>. It invokes UpdateAllViews(). This, in turn, invokes lmScoreView::OnUpdate, and this causes the first lmScoreView repaint.</p>

<p class='justified'>Lets continue the description from <span class="kw1">lmDocument::OnOpenDocument()</span> (the behaviour is similar when <span class="kw1">lmDocument::OnNewDocument()</span> is instaed invoked). The expected standard behaviour would be to instantiate the document (i.e. by parsing a file containing the score to open), to assign a visible name to it (<span class="kw1">SetFilename()</span>) and to display it (<span class="kw1">UpdateAllViews()</span>).</p>

<p class='justified'>
<span class="kw1">lmDocument::SetFilename()</span> invokes <span class="kw1">lmScoreView::OnChangeFilename()</span> and this is the first point at which <span class="kw1">lmScoreView</span> is invoked with a valid pointer to the score.
</p>
    

<p class='justified'>The detailed invocation tree is as follows:
</p><div class="informalexample"><pre class="programlisting">
wxDocManager::OnFileNew
    invokes CreateDocument( wxEmptyString, wxDOC_NEW );
    |
    |   wxDocManager::CreateDocument
    |   |   invokes wxDocument *newDoc = temp-&gt;CreateDocument(path, flags);
    |   |   |   wxDocTemplate::CreateDocument()
    |   |   |   |   Creates a wxDocument (generic, not a lmDocument)
    |   |   |   |   invokes InitDocument
    |   |   |   |   wxDocTemplate::InitDocument([wxDocument])
    |   |   |   |   |   invokes doc-&gt;OnCreate
    |   |   |   |   |   wxDocument::OnCreate()
    |   |   |   |   |   |   invokes GetDocumentTemplate()-&gt;CreateView([wxDocument], flags))
    |   |   |   |   |   |   wxDocTemplate::CreateView([wxDocument])
    |   |   |   |   |   |   |   scoreview constructor
    |   |   |   |   |   |   |   invokes view-&gt;OnCreate(doc, flags))
    |   |   |   |   |   |   |   |   m_pFrame = new lmEditFrame(doc, ..
    |   |   |   |   |   |   |   |       EditFrame constructor
    |   |   |   |   |   |   |   |   m_pCanvas = new lmScoreCanvas
    |   |   |   |   |   |   |   |   m_pFrame-&gt;Show(true);
    |   |   |   |   |   x    
    |   |   |   |   x
    |   |   |   x
    |   |   invokes newDoc-&gt;OnNewDocument()
    |   |   |   lmDocument::OnNewDocument()
    |   |   x
    |   x
    x
x    
</pre></div>

    
<p class='justified'>
<span class="kw1">lmScoreView::OnDraw()</span> is a mandatory override of <span class="kw1">wxView</span>. So we must define an <span class="kw1">OnDraw()</span> method. But the repaint behaviour is controled by the <span class="kw1">OnPaint</span> event on <span class="kw1">lmScoreCanvas</span> and is redirected to <span class="kw1">lmScoreView::RepaintScoreRectangle()</span>. So <span class="kw1">OnDraw()</span> is empty. It is only invoked by the print/preview architecture, for print/preview the document.
</p>

<p class='justified'>In summary:</p>

<p class='justified'><div class="itemizedlist"><ul type="disc">
<li>wxDocManager::CreateDocument is invoked.</li>
<li>A new wxDocument is created</li>
<li>method wxDocument::OnCreate() is invoked</li>
<li>it invokes GetDocumentTemplate()<span class="larger">&#8594;</span>CreateView([wxDocument], flags))</li>
<li>the View is created</li>
<li>then view<span class="larger">&#8594;</span>OnCreate(doc, flags)) is invoked</li>
<li>there the frame and the controller (canvas) are created (owned by the View)</li></ul><div></p>
    
<p class='justified'>Then the framework informs the document by invoking lmDocument::OnOpenDocument() and this causes:</p>

<p class='justified'><div class="itemizedlist"><ul type="disc">
<li>the score is transferred to the document</li>
<li>the lmEditorMode is transferred to the document</li>
<li>the lmEditorMode is instructed to create the Score Procesor. Ownership of lmScoreProcessor is transferred to the view</li>
<li>the lmEditorMode is instructed to customize the ToolBox.</li></ul><div></p>

    
    
<p class='justified'>Therefore:</p>

<A name="TAB1"><B></B></A><p>&nbsp;</p><table class="">
<th class="">object</th><th class="">created by</th><th class="">owned by</th>
<tr class=""><td class="">the document</td><td class="">wxDocManager::CreateDocument</td><td class="">?</td></tr>
<tr class=""><td class="">the score</td><td class="">any object</td><td class="">transferred to the document</td></tr>
<tr class=""><td class="">lmEditorMode</td><td class="">the score creator</td><td class="">transferred to the document</td></tr>
<tr class=""><td class="">the View</td><td class="">wxDocument::OnCreate()</td><td class="">?</td></tr>
<tr class=""><td class="">the Frame</td><td class="">lmScoreView::OnCreate</td><td class="">the view (lmScoreView)</td></tr>
<tr class=""><td class="">the Controller</td><td class="">lmScoreView::OnCreate</td><td class="">the view (lmScoreView)</td></tr>
<tr class=""><td class="">Score procesor</td><td class="">lmEditorMode</td><td class="">transferred to the view</td></tr>
<tr class=""><td class="">ToolBox config</td><td class="">the view (lmScoreView)</td><td class="">the view (lmScoreView)</td></tr>
<tr class=""><td class="">the ToolBox</td><td class="">lmMainFrame</td><td class="">lmMainFrame</td></tr>
</table><center><p><FONT style="margin-left:1em"><I>Table 1. MVC objects creation and ownership</I></FONT></p></center><p>&nbsp;</p>






<h2 class='article'><a name="toc0016"></a>Switching modes when viewing another score</h2>



<p class='justified'>There are two scores open. When activating one of them, how to set up the right ToolBox customizations?</p>

<p class='justified'>The lmTDIClientWindow will know about the switching event (<span class="kw1">OnPageChanged()</span> event handler). and will inform the new child frame (lmTDIChildFrame) being activated</p> 

    <p class='justified'>child<span class="larger">&#8594;</span>OnChildFrameActivated();</p>

<p class='justified'>Default implementation does nothing. But this method is overriden in <span class="kw1">lmEditFrame</span> and in <span class="kw1">lmTextBookFrame</span>.</p>

<p class='justified'>Method lmEditFrame::OnChildFrameActivated() first informs main frame by invoking <span class="kw1">lmMainFrame::OnActiveChildChanged()</span>. And then asks the lmView to set up the appropriate tool box configuration: <span class="kw1">lmView::RestoreToolBoxConfiguration()</span>.</p>




<h2 class='article'><a name="toc0017"></a>Continue in 'exercise mode' after reloading an exercise score</h2>



<p class='justified'>To know that an score was created by an exercise additional information is included in the score. In this way, when the score is reloaded the editor will know about its origin and can ask the user wheter it would like to open it in normal mode or in exercise mode.</p>
    
<p class='justified'>If answer is normal mode the editor will be open in normal mode. When saving a score (opened in normal mode) that contains exercise related information the user will be asked about maintaining the information or removing it.</p>


<p class='justified'>What information to save?. The key information to restore all the edition environment is:</p>

<p class='justified'><div class="orderedlist"><ol type="1">
<li>the score processor in use, needed to process the score to check for user errors.</li>
<li>the current ToolBox customizations</li>
<li>the controller class to create</li></ol><div></p>

<p class='justified'>and all this information is contained in object <span class="kw1">lmEditorMode</span>. Therefore, to restore the edition environment it is enough to save information to reconstruct object <span class="kw1">lmEditorMode</span>.</p>

<p class='justified'>As <span class="kw1">lmDocument</span> will be modified soon to model not only scores but full eBooks, it was necessary to consider if edit mode is information associated to the score or to the document. Scores are just part of the document and we can not have a different environment to edit each score included in a document. A different issue is to enable different tools/controller restrictions for each score. But that&#039;s the information stored in edit mode. So, the conclusion was to associate an edit mode to each score.</p>

<p class='justified'>Now, what information should a <span class="kw1">lmEditorMode</span> save? We can not save information about specific classes used by the appplication. Class names and application structure will change as program evolves. Also the LDP format should be independent from a certain program. Therefore, editMode information should be just a normalized mnemonic giving a clue about how the score was created. This nmemonic must be interpreted by each program.</p>

<p class='justified'>A constructor for lmEditorMode, taking as parameter these nmemonics, was implementd, as well as methods to set and get these nemonics.</p>
    
   
    

<h2 class='article'><a name="toc0018"></a>How is an score saved?</h2>



<p class='justified'>Methods <span class="kw1">lmMainFrame::OnFileSave()</span> and <span class="kw1">lmMainFrame::OnFileSaveAs()</span> invoke the <span class="kw1">lmDocManager</span> who, in turn, ends up invoking <span class="kw1">lmDocument::SaveObject()</span>. All specific code to save an score is in this method.</p>

   
    
    

<h2 class='article'><a name="toc0019"></a>Commands to change an score</h2>



    
<p class='justified'>wxCommand
    It is a base class for modelling an application command, which is an action usually performed by selecting a menu item, pressing a toolbar button or any other means provided by the application to change the data or view.</p>

    <p class='justified'>Instead of the application functionality being scattered around switch statements and functions in a way that may be hard to read and maintain, the functionality for a command is explicitly represented as an object which can be manipulated by a framework or application. When a user interface event occurs, the application submits a command to a wxCommandProcessor object to execute and store.</p>

<p class='justified'>wxCommandProcessor
    It is a class that maintains a history of wxCommand instances, with undo/redo functionality built-in. The wxWidgets framework takes care of calling Undo and Do functions as appropriate, so long as the wxID_UNDO and wxID_REDO menu items are defined in the view menu.</p>
    
<p class='justified'>wxFileHistory
    Encapsulates functionality to record the last few files visited, and to allow the user to quickly load these files using the list appended to the File menu. It is used by wxDocManager,</p> 



<p class='justified'>Two types of commands: those that affect the document (score) and those that affect only the graphical model (i.e. select an object).</p>

<p class='justified'>LenMus implementation requires that all edition commands are issued through an <span class="kw1">lmController</span>. If the view (<span class="kw1">lmScoreView</span>) or other class would like to change anything on a score, it must ask its associated <span class="kw1">lmController</span> to issue the necessary commands. This is a requirement imposed by the model-view-controller architecture.</p>
    
<p class='justified'>Therefore, <span class="kw1">lmScoreCanvas</span> (the controller) is responsible for issuing all score edition commands. For each specific command to execute, the controller creates a <span class="kw1">lmScoreCommand</span> derived class (<span class="kw1">lmCmdXxxxxxxxx</span>) implementing the desired command.</p>

<p class='justified'><span class="kw1">lmScoreCommand</span> methods <span class="kw1">Do()</span> and <span class="kw1">Undo()</span> are then invoked by different mechanisms controlled by <span class="kw1">wxDocManager</span> and <span class="kw1">wxDocument</span> classes. For example, when issuing a <span class="kw1">wxCommnad</span>, method <span class="kw1">Do()</span> is invoked. This design is for supporting the implementation of undo/redo functionalities.</p>

<p class='justified'>Methods <span class="kw1">Do()</span> and <span class="kw1">Undo()</span> interact with the score by issuing undoable commands (modelled by <span class="kw1">lmEditCmdXxxxxx</span> classes, all derived from <span class="kw1">lmEditCmd</span>). An <span class="kw1">lmEditCmd</span> can invoke others <span class="kw1">lmEditCmd</span>, and as long as the login order is correctly preserved, undo is automatic.</p>

<p class='justified'>On its constructor, <span class="kw1">lmEditCmd</span> invokes the necessary methods to perform the desired action. In order to easily identify those methods designed to support the undo/redo mechanism, the name of all methods <b>in any class</b> are prefixed with &#145;Cmd_&#146; and &#145;UndoCmd_&#146;. <span class="kw1">lmEditCmd</span> classes must use only these methods supporting automatic undo/redo.</p>

<p class='justified'>To specify the objects affected by a command the following alternatives are possible:</p>

<p class='justified'><div class="orderedlist"><ol type="1">
<li>No need to specify object (i.e. changing paper size)</li>
<li>To use current caret position.</li>
<li>To specify a cursor.</li>
<li>To use current selection</li>
<li>To specify a selection</li>
<li>To specify an object</li></ol><div></p>
    
<p class='justified'>Therefore, score commands could be classified in three groups:</p>

<p class='justified'><div class="orderedlist"><ol type="1">
<li>No need to specify object (1)</li>
<li>Operating on an object (2, 3, 4)</li>
<li>Operating on a selection (5, 6)</li></ol><div></p>



    

<h2 class='article'><a name="toc0020"></a>Things To Do</h2>



<p class='justified'><div class="itemizedlist"><ul type="disc">
<li>For Linux, need to create the code for lmDocument::SaveObject().</li>
<li>File history is not working properly. Need to review it.</li></ul><div></p>

    
    





<hr class='copyright' />
<a name="legal_notice">&nbsp;</a>
<p class="copyright">
Copyright &copy; 2008-2009 LenMus project
</p>
<p class="justified">
This document is part of the LenMus project. 
Permission is granted to copy, distribute and/or modify this
document under the terms of the <a href='http://www.gnu.org/licenses/fdl.html'>GNU Free Documentation License</a>,
Version 1.3 or any later version published by the Free Software
Foundation; with no Invariant Sections, no Front-Cover Texts and
no Back-Cover Texts.  A copy of the license is included with the program.
</p>

</body></html>
