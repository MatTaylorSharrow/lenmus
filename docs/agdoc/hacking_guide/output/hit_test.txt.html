
<html>
<head>
<title>Hit test, layers and shapes renderization order</title>
<meta http-equiv="Content-Type" content="text/html" />
<link rel="stylesheet" type="text/css" href="screen3.css" type="text/css" />
</head>
<body>




<h1 class='article'>Hit test, layers and shapes renderization order
</h1>

<p class="copyright">
LenMus project (http://www.lenmus.org/)<br />
<a href="#legal_notice">GNU Free Documentation License</a>
</p>


<a name="TOC">&nbsp;</a><p class='toc'>Table of contents</p><p><a class='toc_level1' href='index.txt.html'>Hacking guide main TOC</a></p>
    <a class='toc_level1' href="#toc0001">Hit test</a>
    <a class='toc_level1' href="#toc0002">Layers</a>
        <a class='toc_level2' href="#toc0003">Moving an object below or above</a>
        <a class='toc_level2' href="#toc0004">Implementation details</a>
    <a class='toc_level1' href="#toc0005">References</a>
    <a class='toc_level1' href="#toc0006">TODO</a>




<h2 class='article'><a name="toc0001"></a>Hit test</h2>



<p class='justified'>When the user points with the mouse to an object and clicks on it the program must determine which object has been pointed. This is the &#039;hit test&#039; problem.</p>

<p class='justified'>For straight lines, hit test can be done by comparing the slope of the target line with that of the line formed by the start point of the target line and the click point (the test line). If both slopes match, the object line is hit. This is a good method only for exact click on the line. Otherwise the slope will not match.</p>

<p class='justified'>A better method is the vector distance method. It is just computing the distance from the click point to the line. If the distance is smaller than a certain tolerance value (i.e. 2 pixels) the line is hitted. This is the current implemented method.</p>

<p class='justified'>For a curved-line, it is more difficult to perform hit test. The best way to do this is by using paths. Renderization of a path takes place by flattening the path (converting it to line segments). Therefore the renderaization methods can be used to convert the curved-line to a series of connected straight lines and then the line hit test can be applied to each line segment. This it is not yet implemented in lenmus (see TODO list).</p>

<p class='justified'>Hit test has also to take into account if an object is in part or totally hidden by another object rendered on it. This is normally solved by exploring the objects, for hit test, in reverse order to the renderization order.</p>




<h2 class='article'><a name="toc0002"></a>Layers</h2>



<p class='justified'>When objects overlap, to give the user the freedom to decide on which one will be partially hidden by the other, I decided to use a layers system. Layers are like transparencies stacked one on top of one another to create the final image you see. You can consider each layer as a piece of transparent paper (i.e. cellophane) on which something is drawn. All layers are then stacked each one on top of another. When the layers are stacked, the images appear as if they are all a single image. Top layer images could hide parts of bottom layers thus creating the final image you finally see.</p>

<p class='justified'>By default the following layers are defined:</p>

<p class='justified'><div class="itemizedlist"><ul type="disc">
<li>background layer: by default, nothing on it</li>
<li>staff layer: staff lines, brackets, instrument name, etc.</li>
<li>barlines layer: barlines, repetition signs and related (da capo, etc.)</li>
<li>notes layer: staff objects</li>
<li>annotations layer: aux objects</li>
<li>top layer: by default, nothing on it.</li></ul><div></p>

<p class='justified'>A layer is just the collection of shapes contained in that layer. Renderization will be done by traversing layers and shapes forwards. And hit test must be done traversing layers and shapes backwards.</p>

<p class='justified'>Each <span class="kw1">lmShape</span> has an attribute that defines the layer on which it will be rendered.</p>



<h3 class='article'><a name="toc0003"></a>Moving an object below or above</h3>



<p class='justified'>Each <span class="kw1">lmScoreObj</span> has information (methods <span class="kw1">SetLayer()</span> and <span class="kw1">GetLayer()</span>) about the layer ID in which its shapes must be included.</p> 

<p class='justified'>Moving an shape to a different layer is just a question of changing the layer ID attribute of its parent <span class="kw1">lmScoreObjs</span>.</p>

<p class='justified'>In a layer, last added object will be placed on top of other objects in that layer. Each time the graphical model is re-created this ordering is automatically maintained.</p>

<p class='justified'>Therefore, a problem to consider is that of preserving ordering inside layers: if an object is moved by the user to another layer it is necessary to insert the moved object in the new layer preserving the graphical model creation order. Otherwise, the next time the layout algorithm re-creates the graphical model we will get different results.</p>

<p class='justified'>To illustrate this problem consider the following example:</p>

<p class='justified'>Assume the following shapes IDs are added in sequence (in parenthesis the layer number):
</p><table width="640px" border="0" cellspacing="0" cellpadding="0"><tr><td><pre>
    Shape ID:  34(1), 24(2), 35(2), 68(1), 36(2), 38(2), 58(1), 78(1), 
    order:      1      2      3      4      5      6      7      8
</pre></td></tr></table>

<p class='justified'>After adding the shapes to graphical model in that order, the contents of layers 1 &amp; 2 will be:
</p><table width="640px" border="0" cellspacing="0" cellpadding="0"><tr><td><pre>
    layer 1: 34, 68, 58, 78
    layer 2: 24, 35, 36, 38
</pre></td></tr></table>

<p class='justified'>If user now moves shape 68 to layer 2 it should be placed after object 35, as that will be its place the next time the layout algorithm re-creates the graphical model:
</p><table width="640px" border="0" cellspacing="0" cellpadding="0"><tr><td><pre>

    layer 1: 34, 58, 78
    layer 2: 24, 35, 68, 36, 38
</pre></td></tr></table>

<p class='justified'>And if user decides to move it back to layer 1, for the same reason it must be placed after object 34, returning to its original position.</p>

<p class='justified'>To be able to preserve this ordering we need to know about the order in which a shape is added to the graphical model. The approach followed has been to save this order value in the shape (methods <span class="kw1">SetOrder()</span> and <span class="kw1">GetOrder()</span>) and assign the order value when the shape is added to the graphical model (method <span class="kw1">lmBox::AddShape()</span>).</p>


<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;">
<table border="0" summary="Important">
<tr>
<td rowspan="2" align="center" valign="top" width="25">
<img alt="[Important]" src="images/important.png"></td>
<th align="left">Important</th>
</tr>
<tr><td align="left" valign="top">

The user interface and internal methods to move objects between layers, to add and remove layers and to re-order layers are not yet implemented. But the support to add these features is already in coded.

</td></tr>
</table></div>





<h3 class='article'><a name="toc0004"></a>Implementation details</h3>



<p class='justified'>When a shape is added to a box the <span class="kw1">lmScoreObj</span> that creates the shape must provide layer information.</p>

<p class='justified'><span class="kw1">m_nLayer</span> is a property of the <span class="kw1">lmScoreObj</span> instantiated at creation time with default information for that kind of score obj. The value is exported to LDP only if it does not coincide with the default value.</p>

<p class='justified'>Then, method <span class="kw1">lmBox::AddShape()</span> assigns the shape the creation order number but deosn&#039;t add the shape to any layer, This is because in some cases (for example, when deciding if a measure fits in current system) a <span class="kw1">lmBoxSlice</span> could be deleted and in that case all its shapes must be removed from the layers. To avoid having to remove shapes from the layers, the approach followed has been to populate layers when the lmBoxScore has been prepared. So, at end of method <span class="kw1">lmFormater4::LayoutScore()</span>, before the <span class="kw1">return</span> sentence, the is a line:</p>

<div class="informalexample"><pre class="programlisting">
    pBoxScore-&gt;PopulateLayers();
</pre></div>

<p class='justified'>The purpose of this method is to populate each page layers with the shapes contained in that page.</p>


<p class='justified'>The list of shapes in a layer must be maintained at page level (<span class="kw1">lmBoxPage</span>); otherwise it would be impossible to promote an object out of the render order imposed by traversing the tree of boxes. Also it would be difficult for hit test to take z-order into account if the list is not global but local to each <span class="kw1">lmBox</span>.</p>

<p class='justified'>But if the list of <span class="kw1">lmScoreObj</span> is at page level then it is not possible to filter out by smaller boxes bounding rectangles (systems, slices, etc.) as the list has no the structure of an R-tree (<A href="http://en.wikipedia.org/wiki/R-tree">http://en.wikipedia.org/wiki/R-tree</A>). This implies that for hit tests, in the worst case all the layers must be traversed. Nevertheless, it is expected to have good response time. If that were not the case we should find methods to improve search.</p>

<p class='justified'>Layers in a <span class="kw1">lmBoxPage</span> are organized in a list. You can add all layers you&#039;d like, at any position. But neither under the background layer nor above the top layer.</p>

<p class='justified'>A layer is a collection of <span class="kw1">lmScoreObj</span>. The first <span class="kw1">lmScoreObj</span> is the bottom most object in that layer.</p>

<p class='justified'>By default, each <span class="kw1">lmBoxPage</span> has six predefined layers:</p>

<p class='justified'><div class="itemizedlist"><ul type="disc">
<li>top layer: by default, nothing on it.</li>
<li>annotations layer: aux objects</li>
<li>notes layer: staff objects</li>
<li>barlines layer: barlines, repetition signs and related (da capo, etc.)</li>
<li>staff layer: staff lines, brackets, instrument name, etc.</li>
<li>background layer: by default, nothing on it</li></ul><div></p>

        
<p class='justified'>Whenever the user defines a new layer, it will be inserted a appropriate location in this list (but restricted to be below top layer and above background layer). Layers are global to all pages, that is, if user creates a layer or moves a layer to another position in the layers stack, the operation affects to all the pages.</p>

<p class='justified'>Each layer has an ID number. Layer &#039;top&#039; has ID=5 and layer &#039;backgound&#039; has ID=0. All user layers have ID &gt; 5 and the IDs are assigned in sequence.</p> 

<p class='justified'>Standard layers can not be deleted. A user layer can be deleted and removed but firts, it must be empty (the objects it contains deleted or moved to another layer). There is no need to re-number layers as long as the last used ID is saved.</p>

<p class='justified'>In LDP source the layer order and IDs are saved (once for all the score, as layers structure is common to all pages):</p>

<div class="informalexample"><pre class="programlisting">
    (layers (last ID) ID* )
</pre></div>



<h2 class='article'><a name="toc0005"></a>References</h2>




<p class='justified'><div class="itemizedlist"><ul type="disc">
<li>[1] Hit testing (<A href="http://msdn.microsoft.com/en-us/library/ms969920.aspx">http://msdn.microsoft.com/en-us/library/ms969920.aspx</A>)
    Dennis Crain, Microsoft Developer Network Technology Group, February, 1994. Describes the problem and GDI Win32 methods that can be used to implement hit testing.</li></ul><div></p> 

<p class='justified'><div class="itemizedlist"><ul type="disc">
<li>[2] R-tree (<A href="http://en.wikipedia.org/wiki/R-tree">http://en.wikipedia.org/wiki/R-tree</A>)</li></ul><div></p>



<h2 class='article'><a name="toc0006"></a>TODO</h2>



<p class='justified'><div class="itemizedlist"><ul type="disc">
<li>Remove parameter ExtraWidth in lines.</li></ul><div></p>
   
<p class='justified'><div class="itemizedlist"><ul type="disc">
<li>Hit test: deal with horizontal/vertical lines.</li></ul><div></p>
    
<p class='justified'><div class="itemizedlist"><ul type="disc">
<li>Hit test: deal with other shapes (i.e. ties). Use paths and agg methods.</li></ul><div></p>
    
<p class='justified'><div class="itemizedlist"><ul type="disc">
<li>In some ScoreObjs, the layer can not be changed:</li>
<div class="itemizedlist"><ul type="disc">
<li>InstrGroup.cpp</li>
<li>Staff lines, in VStaff.cpp</li></ul><div></ul><div></p>
        
<p class='justified'><div class="itemizedlist"><ul type="disc">
<li>Save layers information in LDP</li></ul><div></p>
        
<p class='justified'><div class="itemizedlist"><ul type="disc">
<li>Add to ScoreObjs contextual menu, and implement:</li>
<div class="itemizedlist"><ul type="disc">
<li>Move top (to top layer)</li>
<li>Move bottom (to backgrund layer)</li>
<li>Move up (to next layer above)</li>
<li>Move down (to next layer below)</li></ul><div></ul><div></p>

<p class='justified'><div class="itemizedlist"><ul type="disc">
<li>Show/hide layers</li></ul><div></p>
    
<p class='justified'><div class="itemizedlist"><ul type="disc">
<li>Insert/delete layers</li></ul><div></p>
    
<p class='justified'><div class="itemizedlist"><ul type="disc">
<li>Move layer to another position in the layers stack</li></ul><div></p>
 












































































































































































































































































































































<hr class='copyright' />
<a name="legal_notice">&nbsp;</a>
<p class="copyright">
Copyright &copy; 2008-2009 LenMus project
</p>
<p class="justified">
This document is part of the LenMus project. 
Permission is granted to copy, distribute and/or modify this
document under the terms of the <a href='http://www.gnu.org/licenses/fdl.html'>GNU Free Documentation License</a>,
Version 1.3 or any later version published by the Free Software
Foundation; with no Invariant Sections, no Front-Cover Texts and
no Back-Cover Texts.  A copy of the license is included with the program.
</p>

</body></html>
