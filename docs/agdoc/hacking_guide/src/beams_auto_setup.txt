\include ../../agdoc/replacements

\title    {Beamed groups of notes}
\subtitle {How to determine beam info automatically}

\toc

\h1 {Purpose}

When entering notes, the program should take care of grouping notes appropriately to show clearly the underlying metric organization. This document describes the algorithm to compute, for each note in a beamed group, the type of beam to assign to each beam level. The algorithm is implemented in file $$Beam.cpp$$, in method $$lmBeam::AutoSetUp()$$.

\h2 {Beam types}

The number of levels required by a note depends on its duration. As the shortest note is a 256th, it is enough to have six beam levels, as shown in following table:


\vbar_table[Table 1. Levels required by a note; anchor=table1; class=simpletable]
{
\th { Note type  ||  Num levels }
\al { <                   |    }
    eighth (e)  ||1
    16th (s)    ||2
    32nd (t)    ||3
    64th (x)    ||4
    128th       ||5
    256th       ||6
}
    
Each note stores information about the type of beam to assign to each beam level. It is one of the following values:

\code
{
enum lmEBeamType {
    eBeamNone = 0,  //No beam
    eBeamBegin,     //Start of beam in this note
    eBeamContinue,  //Continue a beam
    eBeamEnd,       //Finish a beam in this note
    eBeamForward,   //Forward hook
    eBeamBackward   //Backward hook
};
}

\imgc [beams-auto-setup-figure-1.png] { Figure 1: example of group. See text for an explanation. }

For example, the notes in figure 1 will have the following information:

\vbar_table[Table 2. Information about beam levels stored in each note for example in figure 1; anchor=table1; class=simpletable]
{
\th{ level || Note1    ||  Note2   || Note3    || Note4 }
\al{   |        |            |          |           |   }
       1   || Begin    || Continue || Continue || End
       2   || \emdash  || Begin    || Continue || End
       3   || \emdash  || Forward  || \emdash  || Backward
       4   || \emdash  || \emdash  || \emdash  || \emdash
       5   || \emdash  || \emdash  || \emdash  || \emdash
       6   || \emdash  || \emdash  || \emdash  || \emdash
}
    


\h1 {Algorithm}

First thing to note is that beaming information, at one level, is independent of beaming information at the other levels. Therefore, the algorithm is a loop to compute, in sequence, each beam level.
                                    
We will denote Level(i) as the number of levels for note number i. This number only depends on note duration, as stated in table 1.

The algorithm is as follows:

\algorithm
{
\b{for} CurLevel := 1 to 6
    \b{for} i := 1 to NumNotes
        //If current level is greater than level of Note\sub{i} set beam to None
        \b{if} CurLevel > Level(i) --> None         \b{Rule [0]} 

        \b{else}
            Classify Note\sub{i} as \i{First}, \i{Intermediate}, or \i{Final} and 
            apply the following rules:

            1) \b{Case} \i{First} note:                             
                \b{if} CurLevel > Level(i+1) --> Forward hook   \b{Rule [1.1]}
                \b{else}                     --> Begin          \b{Rule [1.2]}

            2) \b{Case} \i{Intermediate} note:
                \b{if} CurLevel < Level(i)            
                  \b{if} CurLevel > Level(i+1) --> End       \b{Rule [2.1a]}
                  \b{else}                     --> Continue  \b{Rule [2.1b]}

                \b{else if} CurLevel > Level(i-1)
                  \b{if}CurLevel > Level(i+1) --> Hook (fwd or bwd)  \b{Rule [2.2a]}
                  \b{else}                  --> Begin                \b{Rule [2.2b]}

                \b{else} [CurLevel <= Level(i-1)]
                  \b{if} CurLevel > Level(i+1) --> End           \b{Rule [2.3a]}
                  \b{else}                     --> Continue      \b{Rule [2.3b]}

            3) \b{Case} \i{Final} note:
                \b{if} CurLevel <= Level(i-1) --> End             \b{Rule [3.1]}
                \b{else}                      --> Backward hook   \b{Rule [3.2]}

    \b{end for}
\b{end for}
}

From the set of rules in the algorithm it is possible to build the logical functions for each type of beam. But the resulting logical functions are complex and, therefore, its evaluation will need more instructions and processing time than a direct application of the different rules. Therefore, implementation has been done by sequential evaluation of the rules as depicted in the algorithm description.

The algorithm is implemented in file $$Beam.cpp$$, in method $$lmBeam::AutoSetUp()$$.

\h1 {Test cases}

Regression tests:

\imgc [file_004.20_beams.lms.png] { Test file: 004.20_beams.lms }



\ignore
{
Example:

Note num:       1       2       3

Group: ee       l1=1    l2=1     
B1              Bg      En    

Group: ess      l1=1    l2=2    l3=2
B1              Bg      Co      En    
B2              -       Bg      En

Group  e.se     l1=1    l2=2    l3=1 
B1              Bg      Co      En    
B2              -       Hk      -

Group  sse      l1=2    l2=2    l3=1 
B1              Bg      Co      En    
B2              Bg      En      -

Group  ses      l1=2    l2=1    l3=2 
B1              Bg      Co      En    
B2              Fw      -       Bw

}

