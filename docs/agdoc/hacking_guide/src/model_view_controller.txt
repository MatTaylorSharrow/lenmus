\title{The LenMus Model-View-Controller architecture}

\toc

\h1 {The Model-View-Controller architecture}

The Model-View-Controller (MVC) architecture is a well known design pattern that uses three kinds of objects:

    1. The Model is the document object, that is, encapsulates the domain-specific representation of the information on which the application operates, as well as its functionality (domain logic).
    2. The View is its screen representation. Obtains data from the model and presents it to the user.
    3. The controller defines the way the user interface reacts to user input. Receives and translates input to requests on the model or the view.

MVC decouples these parts to reduce the complexity in architectural design and to increase flexibility and reuse. The control flow generally works as follows:

    1. The user interacts with the GUI in some way (i.e., presses a button).
    2. The controller handles the input events from the user interface, and accesses the model, possibly updating it in a way appropriate to the user's action.
    3. The view uses the model (indirectly) to generate an appropriate user interface. The view gets its own data from the model. The model has no direct knowledge of the view. 
    4. The user interface waits for further user interactions, which begins the cycle anew.
    
The views and the model are coupled by establishing a subscribe/notify protocol between them.

A view must ensure that its appearance reflects the state of the model. Whenever the model's data changes, the model notifies views that depend on it. In response, each view gets an opportunity to update itself. This approach lets you attach multiple views to a model to provide different presentations. You can also create new views for a model without rewriting it.



\h1 {Where to place the controller}

LenMus follows the traditional Model-View-Controller design pattern. It is modelled by three abstract classes:

    * \b{lmView} (wxView) \br
      Abstract class from which all views must derive. Related to it there must exist a frame class (derived from %%wxFrame%%) that represents the frame window that frames the visual representation of the view. And a canvas window (derived from %%wxWindow%%) that represents the window on which the view is rendered.
      
    * \b{lmController} (wxWindow) \br
      Abstract class from which all controllers must derive. It is defined in file %%app/ScoreCanvas.h%%.

    * \b{wxDocument} \br
      wxWidgets abstract class from which all models (documents) must derive

User interacts with the GUI: the score canvas, any of its containers (%%lmEditFrame%%, %%lmMainFrame%%), other windows on the GUI (%%lmToolsBox%%), hardware devices (keyboard, MIDI devices), mouse interaction with the GUI (menubars, toolbars, tools box, etc), mouse interaction with the view, etc.

All events coming from all these sources should be send to a single point: the controller. But the problem is where to place it. In the view? In the canvas? In a specific controller class?

By analysing how user events are processed, we can see that interaction (except mouse interaction with the view) can be managed by a an external controller who will receive all events. For mouse interaction with the view it is better to deal with it in the view, since only the view can give meaning to the interaction, and get information about the affected objects and the type of interaction. Once we have this information two strategies are possible:
    
    1. The view sends a command to the CommanProcessor, or
    2. The view asks the controller to send the command.
    
The first alternative leads to the combined ViewController class. Therefore, the second alternative is better as it is up to the particular controller instance to process the command (by sending it) or to ignore it.

Now the question is: create a controller class or use the canvas as controller? I experimented by creating a specific controller class but after creating it I realized that:

    * All events from the canvas will have to be redirected to the controller.
    * The controller needs an event handler but, as it is not a window, it doesn't have one. So to give a handler it will have to be derived from %%wxEvtHandler%%.
    * The canvas has nothing to do but to redirect events to the controller. Moreover, the canvas is a window and therefore, has an event controller without having to define it and to place it in the handlers chain.
    * Creating an specific controller class separated from the canvas means another class to create an manage.
    
From this list my conclusion was to use the canvas as controller. Therefore, in lenmus program the controller plays an additional role: it is the window used by the view to render the document.
   
   

\h1 {The wxWidgets framework}
%%%-----------------------------

The %%wxWidgets%% framework does not implement the MVC model but the Document-View (doc/view) model. The doc/view model is similar to the MVC model, where the Document is equivalent to the Model and the View and the Controller are merged into a single object: the View. wxWidgets has several classes to support the doc/view model. These are the main ones:

 * %%wxDocument%% \br
    This class represents the' document'. Models an application's file-based data. A range of menu commands -- such as open, save, save as -- are supported automatically. %%wxDocument%% is a class derived from wxEvtHandler, and it has information about the doc/view relationship (represented by %%wxDocTemplate%%) and knows about all the views displaying that document.

 * %%wxView%% \br
    The 'View-Controller'. Models the viewing and editing component of an application's file-based data.
    
 * %%wxDocManager%% \br
    All management of documents and views is controlled by an object (singleton) of class %%wxDocManager%%. It is an even handler (derives from %%wxEvtHandler%%) and deals with the most common events and commands related to documents: open, new, save, print, etc. The %%wxDocManager%% is created and owned by the application object (in LenMus, %%lmTheApp%%), and it is passed to the main frame as a parameter when the main frame is created. %%wxDocManager%% only maintains information about all open documents and about the current selected view.

 * %%wxDocTemplate%% \br
    It is mainly information describing the classes to use, for the document and its view, when creating a new document. As %%wxDocManager%%, %%wxDocTemplate%% is also created and owned by the application object (in LenMus, %%lmTheApp%%).  %%wxDocTemplate%%  constructor receives the %%wxDocManager%% as parameter and the constructor associates the created template to the doc manager (by invoking %%wxDocManager::AssociateTemplate(this)%%).
    
 * %%wxDocMDIParentFrame%% \br
    This class provides a default top-level frame for applications using the document/view framework. This class can only be used for applications in which all displayed document windows are constrained inside a single parent window. This model is known as 'Multiple Document Interface' (MDI).
   
I started by trying to use all these wxWidgets classes to implement the MVC model. The first problem I had was how to separate the controller from the view. Later, I found other problems that I also describe in these documentation. I will jump from one issue to another, trying to describe the code, the problems found and the implemented solutions.



\h1 {Basic LenMus classes for the MVC model}

For score edition, the following specific classes are created:

    * The View is \b{lmScoreView} (derived from %%lmView%%). To render the view two more classes are involved:
        * %%lmEditFrame%% (derives from %%lmTDIChildFrame%%, and this in turn from %%wxPanel%%). It is the frame on which we are going to place all windows an controls to render the view. There are several controls (scroll bars and rulers) and a window (the lmScoreCanvas).
        * lmScoreCanvas (derives from %%lmController%%). It is the window on which the score is going to be rendered.
            
    * The Model is \b{lmDocument}. It contains the score to be rendered and a few additional data.
    
    * The Controller is \b{lmScoreCanvas}. Derives from %%lmController%%. All interaction with the document takes place by issuing 'commands' modelled by class %%lmScoreCommand%% (derives from %%wxCommand%%).


For exercises, the involved classes are:

    * The View is \b{lmScoreAuxCtrol}: A window on which a music score is rendered. No direct interaction with the score is allowed (except Play/Stop/Zoom), that is, it is just a display control.
    
    * The Model is \b{lmScore}: the score to be rendered.
    
    * User interaction takes place through the %%lmHtmlWindow%% (the container of the %%lmScoreAuxCtrol%%), so the controller is in it or in its containers classes (%%lmBookFrame%%, %%lmTextBookContrller%%).



\h1 {Special needs in LenMus program}

\h2 {lmMainFrame: using a tabbed document interface (TDI)}
%%%-------------------------------------------------------------

Class %%lmMainFrame%% represents the main frame of the LenMus application. It manages all common controls on the GUI (menu, toolbar, status bar) as well as all application windows (scores to edit, open eBook, etc).

In the %%wxWidgets%% framework, the main frame normally derives from %%wxDocMDIParentFrame%%. As commented, %%wxDocMDIParentFrame%% only supports the Multiple Document Interface (MDI) model. But this model is obsolete and I preferred a tabbed document interface (TDI). Therefore, it was necessary to replace the standard base class %%wxDocMDIParentFrame%%  by something specific for the LenMus program. This new class is %%lmDocTDIParentFrame%%.

The TDI model involves tree classes: the main frame is modelled by a 'Parent Frame' and it contains a 'Client Window' on which 'Child Frame' windows (one for each open document) are displayed.

In LenMus, the 'Client Window' is class %%lmTDIClientWindow%% derived from %%wxAuiNotebook%%. The 'Parent Frame' is class %%lmTDIParentFrame%% derived from %%wxFrame%%. And the 'Child Frame', represented by a tab in the notebook, is class %%lmTDIChildFrame%% derived from %%wxPanel%%.

To add support for the doc/view model (or the Model-View-Controller model), the main frame needs additional methods. Therefore, a different class, named %%lmDocTDIParentFrame%%, was derived from %%lmTDIParentFrame%% for the doc/view model, and requires a %%wxDocManager%% as parameter.

In summary: %%lmMainFrame%% is a %%lmDocTDIParentFrame%%. To display children windows it uses a %%wxAuiNotebook%%. Each tab of this notebook can be:
    * A view in the MVC model (i.e. score to edit) (class %%lmDocTDIChildFrame%%)
    * A independent window (i.e. eBook, Welcome page) (class %%lmTDIChildFrame%%)

Class %%lmMainFrame%% is in file %%app/MainFrame.h%%. All other classes to implement the TDI interface are in %%mdi/ParentFrame.h%%, %%mdi/ClientWindow.h%%, %%mdi/ChildFrame.h%%, and %%mdi/DocViewMDI.h%%.



\h2 {lmDocManager: More ways to create a document}
%%%--------------------------------------------------------------------------------

In the wxWidgets doc/view architecture all management of documents and views is controlled by an object of class %%wxDocManager%%. It deals with the most common events and commands related to documents: open, new, save, print, etc.

In the standard wxWidgets framework behaviour there are two possible methods to create a new document:
 * method %%wxDocument::OnNewDocument()%% is invoked to create a new empty score.
 * method %%wxDocument::OnOpenDocument()%% is invoked to open an existing file containing the document.
 
But in LenMus program, we don't need method %%wxDocument::OnNewDocument()%% because we will never create an empty document. The 'Score New' option will open a 'wizard' for page layout, and it will create an score with some content. Therefore, an empty score will never be created.

And method %%wxDocument::OnOpenDocument()%% (create a document by loading its content from an existing file) is not enough, as we need the following possibilities:

     * Open score (LDP file)
     * Import score (MusicXML file)
     * Open an score created internally, by program, and not saved yet to file (for example, a new score created with the wizard, or an score created by an exercise).
 
 
To deal with these needs I have created a class (%%lmDocManager%%) that derives and replaces %%wxDocManager%%. 

%%lmDocManager%% instance is created by and owned by the application object (%%lmTheApp%%) as well as a %%wxDocTemplate%% object. The %%wxDocTemplate%% constructor receives the %%lmDocManager%% as parameter and, internally, the constructor invokes:
\code
{
m_documentManager->AssociateTemplate(this);
}

Then, when the %%lmMainFrame%% is created, the created %%lmDocManager%% is passed to the main frame as a parameter in the constructor [ method %%lmTheApp::RecreateGUI()%% ]


lmDocManager takes also responsibility for orchestrating the creation, destruction and management of documents, and of its Views/Controllers.




\h2 {The ToolBox}
%%%------------------

All editor interaction with the score takes place through an %%lmController%%. To define controller response to user commands, each %%lmController%% could use any desired mechanism. A common way of doing this is by placing 'selection/option buttons' on the main toolbar. Then user actions are interpreted based on toolbar selected options.

But I don't like the idea of using the toolbar as it will end up with too many buttons and also it is more difficult to include controls (comboxes, radio buttons, help texts, etc.). So I dedided to replace to toolbar with something better and more user-oriented. The toolbar normally ends up being a mess of buttons and controls with no apparent organization. And it takes too much space on top of the window. So, I decided to experiment with a palette of tools (the ToolBox) similar to that used in many CAD applications.

As the tendency is to have wider screens (for multimedia) I though it would be better to place the toolbox on the left (right) side instead of on top, to give more space for the score. Anyway user should be able to choose a horizontal layout and top/bottom placement.

So, to define controller response to user commands %%lmScoreCanvas%% uses an associated ToolBox window (class %%lmToolBox%%). This toolbox is built independly from the controller (%%lmScoreCanvas%%) because it is going to be shared by all open %%lmEditFrames%%. This main toolbox is owned and managed by %%lmMainFrame%% and it is assigned to each open %%lmScoreCanvas%%.


\h2 {Score editor 'modes'}
%%%--------------------------------

For simple exercises there is no need for the user to interact with the score. For example, in an exercise to identify intervals, an score with an interval is presented to the user and the user just give her/his answer by clicking on a button.

But for more advanced exercises it would be better to use the score editor to elaborate the answer. For example: dictation exercises, harmony exercises, etc.

To customize the score editor for the needs of a particular exercise, the score editor must support 'editor modes'. An 'editor mode' is a set of restrictions and customizations to force the score editor to behave in a predefined way. For example, for four-parts harmony exercises, the editor could be restricted to use only four voices.


\h2 {ToolBox customizations}
%%%---------------------------

Using the score editor for exercises not only requires to support editor modes but also creates the need to customize the ToolBox (%%lmToolBox%% class), for example to include special buttons and tools for the exercise.

And this, in turns, requires specific customizations in the controller (%%lmScoreCanvas%% class) to deal with the added tools.

Implementation of this idea is just a question of using specialized controllers and of dynamically configuring the toolbox.

As the main toolbox is shared between all open editor windows and as each one them could be in a different 'edition mode', the tool box should allow for multiple configurations.


\h2 {Score processors}
%%%--------------------

There is a need for tools to process (or alter) a full score. For example, a tool to transpose a score, to add colours to voices, to make a piano reduction, etc. All these tools will derive from abstract class %%lmScoreProcessor%%:  A class to process (or alter) a full score.

It must have at least a method %%DoProcess()%% to perform the specific processing it represents. And can issue edit commands.

It can also display windows, for example, to ask for the control parameters required by the process to perform, or to show the result of the process.

From the MVC point of view an score processor is part of the controller: receives user interaction (perhaps just the command 'do process') and issues commands to alter the score.

    

\h2 {Exercises using the full score editor}
%%%-----------------------------------------

The idea is to use the score editor for exercises. The problem is presented as a score that the student has to modify. As the full editor is used, the student can save the score so that he/she can later continue the exercise.

For checking user answer (the edited score) score and adding markup to display errors and suggestions an score processor could be used. This also has the advantage of a possible re-usability of the score checking code to build a general purpose tool, usable not only in exercises.

Independently of the solution chosen to check for errors in the user exercise (the score) there is a need to add special tools (i.e. 'check for errors' and 'remove all markup' buttons) to the toolbox.

Fore exercises using a score processor, the control flow is as follows: 

    * an instance of the appropriate lmScoreProcessor is be created.
    * the lmScoreProcessor is requested to add a 'spacial tools' panel to the ToolBox. It will include only the links supported by the lmScoreProcessor .
    * The score editor will be opened in appropriate mode, to edit the score.

lmFullEditorExercise *is not* a class derived from lmScoreProcessor. The score processor is part of the controller and, therefore, must not be created/owned by the exercise. This implies that the only links that will be added to the 'special tools' panel in the ToolBox will be those required by the used lmScoreProcesor (i.e: 'Check solution'). Any other required control (i.e, 'New problem', 'Exercise options') will be displayed on the eBook control.


\h2 {Reloading an exercise score}
%%%--------------------------------------------------------------------

In order to be able to continue an exercise, we need to save meta-information with the score to know that the score was created by an exercise and what is the environment (toolbox customizations, editor mode, controller, etc) that must be setup to continue the exercise. Then, there is a need to orchestrate the creation of all that environment.




\h1 {Dealing with all these needs}
%%%---------------------------------


To deal with all previously required needs the following approach was followed:

        * the controller has now an associated ToolBox.
        * the toolbox could be customized for each open score.
        * the controller could be different for each open score.
        * one or more ScoreProcessors could modify an score.
        
Therefore, the controller is now composed by three classes:
        * %%lmScoreCanvas%%
        * %%lmToolBox%%
        * Optionally, one or more instances of %%lmScoreProcessor%%.
        
The standard %%wxWidgets%% doc/view model uses:
 
    * %%wxDocManager%% to manage the documents
    * %%wxDocTemplate%% for relating document types (different file extensions -- i.e. .txt, .drw) to different document/views.
    
Now, in LenMus I have defined:

    * %%lmDocManager%% (derived from %%wxDocManager%%) to extend base class for dealing with some needs:
        * Using MVC model instead of doc/view model
        * More ways to create a document.
        
    * %%lmEditorMode%%, to be used instead %%wxDocTemplate%%. %%lmEditorMode%% provides additional information, such as the controller type, the required ToolBox customizations, and the optional Score processor to use.
 



\h2 {Creating the document, the view/controller. First renderization of lmScoreView}
%%%----------------------------------------------------------------------------------

The wxWidgets document/view architecture is used, and class %%wxDocManager%% orchestrates the creation of the document and the view.

The process starts when an event MENU_File_Open or MENU_File_New is created (i.e. via main menu 'file > new'  or 'file > open').

In response to these events, the associated method in lmMainFrame (i.e. lmMainFrame::OnFileOpen() ) is invoked. Then method m_pDocManager->OpenFile() is invoked. This method does two things:

    * First it invokes lmDocManager::DoOpenDocument() to create the document. This
    first creates an empty lmDocument instace. Then it creates the lmScoreProcessor and informs the document [by invoking lmDocument::OnCreateCommandProcessor()]. Next, it asks the document to create the View/Controller by invoking lmDocument::OnCreate(). And, finally, it asks the document to load content in the document, by invoking either lmDocument::OnOpenDocument(path), lmDocument::OnNewDocumentWithContent(pScore) or lmDocument::OnImportDocument(path), depending on the specific way of creating the document.
    
    * Second, it asks the document to customize the controller. by invoking lmDocument::OnCustomizeController()

But this instace is empty, that is, it doesn't contains any score yet. Therefore, lmDocument member variable %%m_pScore%% will be always %%NULL%% at this point.

Next, %%wxDocManager%% proceeds to create the view. The invokation path for this complex but, finally, the following invocation takes place: %%wxDocTemplate::CreateView()%%. This invokes the view constructor followed by an invocation to %%wxWiew::OnCreate()%%.

As wxWidgets doc/view framework doesn't create a controller class, I'm putting the responsibility for creating the controller on the view. Method %%lmWiew::OnCreate()%% creates a new %%lmEditFrame%% (%%lmDocTDIChildFrame%%) and its associated %%lmScoreCanvas%% (the controller). 

Creating the frame at this point has a drawback: the frame is created and painted. This causes and invokation to lmScoreView::OnSetFocus and when the canvas is going to be painted, to lmScoreView::RepaintScoreRectangle. But at this point the score is NULL and the method terminates doing nothing. Therefore, the canvas client area is not painted, and remains in grey color.

Then the framework informs the document by invoking %%lmDocument::OnOpenDocument()%%. It invokes UpdateAllViews(). This, in turn, invokes lmScoreView::OnUpdate, and this causes the first lmScoreView repaint.

Lets continue the description from %%lmDocument::OnOpenDocument()%% (the behaviour is similar when %%lmDocument::OnNewDocument()%% is instaed invoked). The expected standard behaviour would be to instantiate the document (i.e. by parsing a file containing the score to open), to assign a visible name to it (%%SetFilename()%%) and to display it (%%UpdateAllViews()%%).

\important
{
%%lmDocument::SetFilename()%% invokes %%lmScoreView::OnChangeFilename()%% and this is the first point at which %%lmScoreView%% is invoked with a valid pointer to the score.
}
    

The detailed invocation tree is as follows:
\code
{
wxDocManager::OnFileNew
    invokes CreateDocument( wxEmptyString, wxDOC_NEW );
    |
    |   wxDocManager::CreateDocument
    |   |   invokes wxDocument *newDoc = temp->CreateDocument(path, flags);
    |   |   |   wxDocTemplate::CreateDocument()
    |   |   |   |   Creates a wxDocument (generic, not a lmDocument)
    |   |   |   |   invokes InitDocument
    |   |   |   |   wxDocTemplate::InitDocument([wxDocument])
    |   |   |   |   |   invokes doc->OnCreate
    |   |   |   |   |   wxDocument::OnCreate()
    |   |   |   |   |   |   invokes GetDocumentTemplate()->CreateView([wxDocument], flags))
    |   |   |   |   |   |   wxDocTemplate::CreateView([wxDocument])
    |   |   |   |   |   |   |   scoreview constructor
    |   |   |   |   |   |   |   invokes view->OnCreate(doc, flags))
    |   |   |   |   |   |   |   |   m_pFrame = new lmEditFrame(doc, ..
    |   |   |   |   |   |   |   |       EditFrame constructor
    |   |   |   |   |   |   |   |   m_pCanvas = new lmScoreCanvas
    |   |   |   |   |   |   |   |   m_pFrame->Show(true);
    |   |   |   |   |   x    
    |   |   |   |   x
    |   |   |   x
    |   |   invokes newDoc->OnNewDocument()
    |   |   |   lmDocument::OnNewDocument()
    |   |   x
    |   x
    x
x    
}

    
\important
{
%%lmScoreView::OnDraw()%% is a mandatory override of %%wxView%%. So we must define an %%OnDraw()%% method. But the repaint behaviour is controled by the %%OnPaint%% event on %%lmScoreCanvas%% and is redirected to %%lmScoreView::RepaintScoreRectangle()%%. So %%OnDraw()%% is empty. It is only invoked by the print/preview architecture, for print/preview the document.
}

In summary:

    * wxDocManager::CreateDocument is invoked.
    * A new wxDocument is created
    * method wxDocument::OnCreate() is invoked
    * it invokes GetDocumentTemplate()->CreateView([wxDocument], flags))
    * the View is created
    * then view->OnCreate(doc, flags)) is invoked
    * there the frame and the controller (canvas) are created (owned by the View)
    
Then the framework informs the document by invoking lmDocument::OnOpenDocument() and this causes:

    * the score is transferred to the document
    * the lmEditorMode is transferred to the document
    * the lmEditorMode is instructed to create the Score Procesor. Ownership of lmScoreProcessor is transferred to the view
    * the lmEditorMode is instructed to customize the ToolBox.

    
    
Therefore:

\vbar_table[Table 1. MVC objects creation and ownership; anchor=TAB1]
{
\th{object      || created by                   || owned by}
%%%-M-----------+-------------------------------+----------------------------------
the document    || wxDocManager::CreateDocument || ?
the score       || any object                   || transferred to the document
lmEditorMode    || the score creator            || transferred to the document

%%%-V-----------+-------------------------------+----------------------------------
the View        || wxDocument::OnCreate()       || ?
the Frame       || lmScoreView::OnCreate        || the view (lmScoreView)

%%%-C-----------+-------------------------------+----------------------------------
the Controller  || lmScoreView::OnCreate        || the view (lmScoreView)
Score procesor  || lmEditorMode                 || transferred to the view
ToolBox config  || the view (lmScoreView)       || the view (lmScoreView)
the ToolBox     || lmMainFrame                  || lmMainFrame
}





\h1 {Switching modes when viewing another score}
%%%--------------------------------------------------

There are two scores open. When activating one of them, how to set up the right ToolBox customizations?

The lmTDIClientWindow will know about the switching event (%%OnPageChanged()%% event handler). and will inform the new child frame (lmTDIChildFrame) being activated 

    child->OnChildFrameActivated();

Default implementation does nothing. But this method is overriden in %%lmEditFrame%% and in %%lmTextBookFrame%%.

Method lmEditFrame::OnChildFrameActivated() first informs main frame by invoking %%lmMainFrame::OnActiveChildChanged()%%. And then asks the lmView to set up the appropriate tool box configuration: %%lmView::RestoreToolBoxConfiguration()%%.



\h1 {Continue in 'exercise mode' after reloading an exercise score}
%%%--------------------------------------------------------------------

To know that an score was created by an exercise additional information is included in the score. In this way, when the score is reloaded the editor will know about its origin and can ask the user wheter it would like to open it in normal mode or in exercise mode.
    
If answer is normal mode the editor will be open in normal mode. When saving a score (opened in normal mode) that contains exercise related information the user will be asked about maintaining the information or removing it.


What information to save?. The key information to restore all the edition environment is:

    1. the score processor in use, needed to process the score to check for user errors.
    2. the current ToolBox customizations
    3. the controller class to create

and all this information is contained in object %%lmEditorMode%%. Therefore, to restore the edition environment it is enough to save information to reconstruct object %%lmEditorMode%%.

As %%lmDocument%% will be modified soon to model not only scores but full eBooks, it was necessary to consider if edit mode is information associated to the score or to the document. Scores are just part of the document and we can not have a different environment to edit each score included in a document. A different issue is to enable different tools/controller restrictions for each score. But that's the information stored in edit mode. So, the conclusion was to associate an edit mode to each score.

Now, what information should a %%lmEditorMode%% save? We can not save information about specific classes used by the appplication. Class names and application structure will change as program evolves. Also the LDP format should be independent from a certain program. Therefore, editMode information should be just a normalized mnemonic giving a clue about how the score was created. This nmemonic must be interpreted by each program.

A constructor for lmEditorMode, taking as parameter these nmemonics, was implementd, as well as methods to set and get these nemonics.
    
   
    
\h1 {How is an score saved?}
%%%-------------------------

Methods %%lmMainFrame::OnFileSave()%% and %%lmMainFrame::OnFileSaveAs()%% invoke the %%lmDocManager%% who, in turn, ends up invoking %%lmDocument::SaveObject()%%. All specific code to save an score is in this method.

   
    
    
\h1 {Commands to change an score}
%%%--------------------------------

    
wxCommand
    It is a base class for modelling an application command, which is an action usually performed by selecting a menu item, pressing a toolbar button or any other means provided by the application to change the data or view.

    Instead of the application functionality being scattered around switch statements and functions in a way that may be hard to read and maintain, the functionality for a command is explicitly represented as an object which can be manipulated by a framework or application. When a user interface event occurs, the application submits a command to a wxCommandProcessor object to execute and store.

wxCommandProcessor
    It is a class that maintains a history of wxCommand instances, with undo/redo functionality built-in. The wxWidgets framework takes care of calling Undo and Do functions as appropriate, so long as the wxID_UNDO and wxID_REDO menu items are defined in the view menu.
    
wxFileHistory
    Encapsulates functionality to record the last few files visited, and to allow the user to quickly load these files using the list appended to the File menu. It is used by wxDocManager, 



Two types of commands: those that affect the document (score) and those that affect only the graphical model (i.e. select an object).

LenMus implementation requires that all edition commands are issued through an %%lmController%%. If the view (%%lmScoreView%%) or other class would like to change anything on a score, it must ask its associated %%lmController%% to issue the necessary commands. This is a requirement imposed by the model-view-controller architecture.
    
Therefore, %%lmScoreCanvas%% (the controller) is responsible for issuing all score edition commands. For each specific command to execute, the controller creates a %%lmScoreCommand%% derived class (%%lmCmdXxxxxxxxx%%) implementing the desired command.

%%lmScoreCommand%% methods %%Do()%% and %%Undo()%% are then invoked by different mechanisms controlled by %%wxDocManager%% and %%wxDocument%% classes. For example, when issuing a %%wxCommnad%%, method %%Do()%% is invoked. This design is for supporting the implementation of undo/redo functionalities.

Methods %%Do()%% and %%Undo()%% interact with the score by issuing undoable commands (modelled by %%lmEditCmdXxxxxx%% classes, all derived from %%lmEditCmd%%). An %%lmEditCmd%% can invoke others %%lmEditCmd%%, and as long as the login order is correctly preserved, undo is automatic.

On its constructor, %%lmEditCmd%% invokes the necessary methods to perform the desired action. In order to easily identify those methods designed to support the undo/redo mechanism, the name of all methods **in any class** are prefixed with ''Cmd_'' and ''UndoCmd_''. %%lmEditCmd%% classes must use only these methods supporting automatic undo/redo.

To specify the objects affected by a command the following alternatives are possible:

    1. No need to specify object (i.e. changing paper size)
    2. To use current caret position.
    3. To specify a cursor.
    4. To use current selection
    5. To specify a selection
    6. To specify an object
    
Therefore, score commands could be classified in three groups:

    1. No need to specify object (1)
    2. Operating on an object (2, 3, 4)
    3. Operating on a selection (5, 6)



    
\h1 {Things To Do}
%%%-------------------

    * Code for lmDocument::SaveObject() in Linux.

    
    



