\include ../../agdoc/replacements

\title {Scores: Objects model}

\toc



\h1 {Objects model}
%%%-----------------------------------------

In document \href0 [score_representations] {Scores: the internal model} there is a general description of main container classes and how they do relate between them. Here we are going to see the model in detail. It is depicted in figure 2.

\imgc [om_2_internal_model.jpg] { Figure 2. Hierarchy of score objects }
        
The approach followed has been to capture the score structure by splitting the representation in containers and objects. For example, we could imagine the staff as a container of notes and rests. The root class is %%lmScoreObj%%, and represents any object related to the score model, including the score itself. %%lmScoreObj%%s:

    * Can have options (%%lmObjOptions%% object)
    * Can own %%lmAuxObjs%%. To this end they:
        * Must provide origin position
        * Must provide TenthsToLogical conversion methods.

%%lmScoreObj%% has two specializations: 

 * %%lmContainerObj%%: main grouping elements, such as the score itself, instruments and vstaffs. To simplify the model, as they do not share common operations this class is not really created, and all container classes derive directly from %%lmScoreObj%%.

 * %%lmComponentObj%%: Anything that can appear in an score.


\h2 {Container classes}
%%%----------------------

There are three container classes:

\b{1. lmScore}

The top most container. A %%lmScore%% is, mainly, a collection of %%lmInstruments%% and the collection of %%lmAuxObjs%% not tied to other containers, such as score titles. It is responsible for:

    * score play back (Play, PlayMeasure, Pause, Stop, WaitForTermination)
    * serving highlight events (ScoreHighlight)
    * Debug and dump (Dump, DumpMidiEvents)
    * Creating/exporting source code (SourceLDP, SourceXML)
    * Manage instruments
    * Manage score titles
    * identification (score name, score ID)
        
\b{2. lmInstrument}

A container for all the information and objects related to an instrument. It contains the %%lmVStaff%% object that represents a virtual infinite staff for the music symbols associated to the instrument. It is responsible for:

    * VStaff management
    * Debug and dump
    * Source code methods (SourceLDP, SourceXML)
    * MIDI configuration (m_nMidiInstr, m_nMidiChannel)
    * Instrument name and indentation (m_nIndentFirst, m_nIndentOther, m_pName, m_pAbbreviation)


\b{3. lmVStaff}

This object, that stands for \i{\b{V}irtual \b{Staff}}, represents any staff layout. It is a container for all the %%lmScoreObjs%% (notes, rests, etc.) of its owner %%lmInstrument%% and also contains all needed information about how the staff is rendered (number of staves, lines, etc.). It is responsible for:

    * Staff management
    * Clef management
    * Time signature management
    * Key signature management
    * notes and rests management
    * barlines management
    * control ScoreObjs management (AddNewSystem, ShiftTime)
    * words directions management
    * Measures management (GetNumMeasures)
    * Rendering methods (DrawStaffLines, DrawProlog, NewLine, SetUpFonts, GetStaffLineThick)
    * renderization helper methods (GetXPosFinalBarline)
    * Units conversion (TenthsToLogical)
    * Dump method
    * Source code methods (SourceLDP, SourceXML)
    * notes context management
    * sound related methods (ComputeMidiEvents)
    
It contains the collection of staff objects (object of class %%lmColStaffObjs%%) and the collection of staff layouts(%%lmStaff%% objects).


\h2 {Component classes}
%%%----------------------

%%lmComponentObj%% is any object modelling a renderizable (but not necessarily visible) thing that can appear on a score. 

    * They have type and identification number (m_nType, m_nId)
    * Could be draggable (m_fIsDraggable)
    * They have positioning info: origin (m_paperPos), page num (m_nNumPage)
    * Could be selected, so they have a selection rectangle (m_fSelected, m_selRect)
    * can be rendered (methods: Draw, GetBitmap) Two phases draw. Invoke DrawObject.
    * Can have Aux objects attached (m_pAuxObjs)
    * Dump method
    
As they are renderizable:
    * they can own shapes
    * They know how to convert LUnits to Tenths, and viceversa
        
There are two derived classes:

\h3 {lmStaffObj}

An StaffObj is any object that must have an VStaff as owner (measure-attached objects). In this group we have the main musical elements, normally with duration (notes/rests) or time positioned (clef, key signature, time signature). They are in a staff/measure, so they are attached to an VStaff. They normally 'consume' time and so layout is controlled by time position.

    * Have timePos information
    * Have VStaff information
    * Specific Layout methods
    * Layout is controlled mainly by time position
    * They can have duration (time positioned: m_rTimePos)
    * They can own AuxObjs
    * Source code methods (SourceLDP, SourceXML)
    * They have staff information (m_pVStaff, m_nStaffNum, m_numMeasure)
    
Examples of derived objects: %%lmNote, lmRest, lmClef, lmTimeSignature, lmKeySignature, lmBarline, lmMetronomeMark, lmNotation%% (Spacer, Anchor, ScoreAnchor), %%lmScoreText, lmSOControl%%(new system).


\h3 {lmAuxObj}

An %%lmAuxObj%% is any object that is not attached to a staff but to one or more %%lmStaffObj%% (note-attached objects). For example:

    a) Attached to one %%lmStaffObj%%: 
        * a note plus its accidental symbol;
        * caesura marks, texts, and some notations (i.e. articulations) attached to notes; 
        * repeat signs attached to barlines, etc.

    b) Attached to two %%lmStaffObj%%:
        * ties attached to two notes, 
        * wedges for dynamics, etc. 
    
As they do not consume time, the Layout phase is done by specific methods, controlled by owner objects.

%%lmAuxObj%%s can be attached both to %%lmStaffObj%% and to %%lmAuxObj%%. For example: to put a coloured box around a caesura mark, with an arrow pointing to it and a text attached to the arrow. This can be achieved be drawing a box, an arrow and the text, positioning them as desired, grouping them to form a compound graphic object and attaching it to the caesura %%lmAuxObj%%.

As %%lmAuxObj%%s are not %%lmStaffObj%%s they can not be attached directly to an staff. In order to allow for placing %%lmAuxObj%%s on the staff it is necessary design a mechanism for this. The current solution is by using special StaffOjs (%%lmSpacer, lmAnchor, lmScoreAnchor%%).


\h3 {Owning AuxObjs}
%%%--------------------

It should be possible to have AuxObjs not attached only to StaffObjs but to many places. For example: assume a text box (AuxObj) owned by a fermata (AuxObj), owned by a note (StaffObj).

Another example: Score titles, Instrument names, etc are examples of AuxObjs not owned by StaffObjs.

This implies that AuxObjs can own other AuxObjs. But AuxObjs layout requires that:
  a) the owner must provide positioning information. AuxObjs are relative positioned
  b) the owner must be able to do TenthsToLogical conversions.

Therefore, the only restriction would be that the root of owners chain must not be an AuxObj. In summary:

 * In order to own AuxObjs it is necessary to be able to do TenthsToLogical conversions.
 * An AuxObj can own other AuxObjs but the root of owners chain must not be an AuxObj (otherwise it will never be rendered!). * At creation, an AuxObj has no owner. The owner must be set at attachment time, and must be updated at each attachment/detachment
 * If its owner is a StaffObj, measurements can be in tenths, as can be converted to LUnits. Otherwise, if owner chain reaches a VStaff/Staff, measurements can also be in tenths and this grand-father VStaff will be used for units conversion. Otherwise, units must be absolute.


\h2 {Auxiliary classes}
%%%----------------------

Finally, I have defined other auxiliary objects, non-derived from any other one:
    
 * lmBeam:  info about the beam for a group of notes
 * lmChord: info about a chord
 * lmArch: info to draw an arch
 * lmContext: info about current accidentals 
 * lmBasicText: info for a text (font size, font family, ..)
 * lmStaff: Properties for each staff on a VStaff (num.lines, spacing, ...)
 * lmAccidental: accidentals in notes





\h1 {Objects model: history and evolution}
%%%-----------------------------------------

When I stated the LenMus program I didn't have any previous experience about modelling music. I googled for music representation and found \href [http://www.recordare.com/xml.html] {MusicXML}, then a starting project (version 0.7). It was inadequate to my purposes as I needed positioning information and MusicXML 0.7 didn't have plans to include this information. Therefore, to gain first hand experience about music representation problems I decided to design my own representation language: LDP (Lenguaje De Partituras, meaning 'Language For Scores'). But I also though it would be wise to have some reference and so I  started by following the MusicXML model. A second reason to follow it was that I liked to implement export/import MusicXML and so, to simplify this objective, my internal representation should allow for easy conversion to/from MusicXML.

\h2 {How is music represented in MusicXML}
%%%-----------------------------------------

 * Score is a collection of instruments (%%<parts>%%). Titles are directly owned by the score:
\code
{
    <!ELEMENT score-partwise (%score-header;, part+)>
}
   
 * %%<part>%% contains all measures for one instrument
\code
{
        <!ELEMENT part (measure+)>
}

 * %%<measure>%% contains all the information:
\code
{
        <!ELEMENT measure (%music-data;)>
        <!ENTITY % music-data
            "(note | backup | forward | direction | attributes |
            harmony | figured-bass | print | sound | barline | 
            grouping | link | bookmark)*">
}

        
 * %%<notes>%% have additional elements, such as %%<notations> <lyrics> <technical> <fermata>%% etc. Let me refer to all them by %%<notations>%%:
\code
{
        <!ELEMENT note 
        ( ( (grace, %full-note;, (tie, tie?)?) |
               (cue, %full-note;, duration) |
            (%full-note;, duration, (tie, tie?)?)),
          instrument?, %editorial-voice;, type?, dot*, accidental?, time-modification?,
          stem?, notehead?, staff?, beam*, notations*, lyric*)>
}


 * %%<notations>%% are musical notations, not other elements (directions):
\code
{
        <!ELEMENT notations
            (%editorial;, 
            (tied | slur | tuplet | glissando | slide | 
            ornaments | technical | articulations | dynamics |
            fermata | arpeggiate | non-arpeggiate | 
            accidental-mark | other-notation)*)>
            
        <!ELEMENT articulations
            ((accent | strong-accent | staccato | tenuto |
              detached-legato | staccatissimo | spiccato |
              scoop | plop | doit | falloff | breath-mark | 
              caesura | stress | unstress | other-articulation)*)>
}

            
 * %%<directions>%% are not note-specific, and therefore might attach to a
    %%<part>%% or the overall score. i.e. texts:
\code
{
        <!ELEMENT direction (direction-type+, offset?,
            %editorial-voice;, staff?, sound?)>
        <!ELEMENT direction-type (rehearsal+ | segno+ | words+ |
            coda+ | wedge | dynamics+ | dashes | bracket | pedal | 
            metronome | octave-shift | harp-pedals | damp | 
            damp-all | eyeglasses | scordatura | image |
            accordion-registration | other-direction)>
}


I also took into account that in the Sibelius model all objects are attached to an staff. As this was not in contradiction with the MusicXML model I started assuming that any object will be a %%lmStaffObj%%, even if it does not consume time. %%<directions>%% where the only exception but they can be considered as attached to the score, as well as titles: everything fitted perfectly.

When I started to implement %%<notations>%% I found that as they are attached to %%<notes>%% they did not fit in the %%lmStaffObj%% model. So I created a new class for %%<notations>%%: %%lmAuxObj%%

As I added more musical symbols the model became more and more complex. Finally I decided to revise it and to simplify it. The resulting model is the previously described one. Nevertheless, it needs refinements and changes.


