\include ../../agdoc/replacements

\title    {Handlers for shapes}

\toc 

\h1 {Handlers}
%%%------------

[in files "graphic/Handlers.cpp & .h"]



Handlers are the small squares (or circles, diamonds or other marks) at specific points of a shape (the 'controlled shape'), that are used to change its position or layout.

But when an object is selected and have handlers, apart of rendering the handlers themselves it could be necessary to render some handler related shapes, such as lines joining the handlers, lines joining a handler with its owner %%lmGMObject%% (i.e., for ties, the handlers could draw small line segments joining the handler to the S-line) or lines surrounding the controlled shape. All these handler related lines are also handlers, as the user can point to them for dragging/moving the whole controlled shape.

Handlers are implemented as %%lmShape%% objects, for several reasons. One of them is to simplify detecting when the mouse is over a handle and to simplify dragging, using the same architecture than for 'normal' shapes.



\h2 {Handlers renderization}
%%%-----------------------------

To render handlers some issues should be considered:

 a) When an object is selected and have handlers, apart of rendering the handlers themselves it could be necessary to render some handler related shapes, such as lines joining the handlers, lines joining a handler with its owner %%lmGMObject%% (i.e., for ties, the handlers could draw small line segments joining the handler to the S-line) or lines surrounding the controlled shape. This implies that renderization is different when the object is selected.

 b) When a handler is dragged the controlled shape must be redrawn in the new resulting position/shape, and these dragging and moving operations should be very fast. This implies that we can not re-render the whole page and create new bitmaps at every small change.
 
Due to these considerations implementation is as follows:

 * Handlers are not rendered during shapes renderization. Instead, if during renderization an object has the need to draw handlers (for instance, if the object is selected) if MUST inform its parent %%lmBoxPage%% by invoking method %%lmBoxPage::OnNeedToDrawHandlers()%%.

 * Each %%lmBoxPage%% maintains a list of objects having requested to be rendered with handlers and, when appropriate, it will invoke method %%RenderWithHandlers()%% for those objects, so that they can do it.

 * Handlers are rendered in method %%lmScoreView::TerminateRepaint()%%. This method is invoked by %%lmScoreCanvas::OnPaint()%% to inform that there are no more screen rectangles to repaint. At that point the pages bitmaps are ready and then we can proceed to paint handlers , but not on the bitmaps themselves but by XOR over them (with no anti-aliasing). To request do it, method %%lmScoreView::TerminateRepaint()%% invokes %%lmBoxPage::DrawAllHandlers()%% for all visible pages.

 * Any %%lmGMObject%% with handlers must have two renderization methods:
    * %%Render()%%: The usual normal anti-aliased renderization with no handlers.
    * %%RenderWithHandlers()%%: A method to render the object selected, with handlers. Must used direct draw DC, instead of anti-aliased DC.
    
\note
{
To think: %%RenderWithHandlers()%% methods really means 'RenderSelected'. Should we rename  %%RenderWithHandlers()%% into %%RenderSelected()%% and ask all %%lmGMOobj%% to implement it? If the object has handlers it will implement it with direct draw DC. A default implementation for objects without handlers could be provided.
}


\h2 {How handlers interact with the controlled shape}
%%%------------------------------------------------------

When a handler is dragged the controlled shape is informed by invoking methods %%OnHandlerDrag()%% and %%OnHandlerEndDrag()%%.

 * During handler drag the controlled shape must:
     * store new handler coordinates and update shape points to take into account handler displacement.
     * re-draw the shape at new position/geometry by invoking %%RenderWithHandlers()%%.

 * At end of handler drag, the controlled shape must:
    * compute shifts from start of drag points
    * issue a %%MoveObjectPoints()%% command. Before doing it, as handlers and shape points have been already displaced during drag, it is necessary to restore the original positions in the shape, to avoid double displacements.



\h2 {What to do to add handlers to a shape}
%%%-----------------------------------------------

 * Decide on object layout when selected (squared handlers, line handlers, aux lines) and add defines for handlers IDs.
 
 * Define pointers for the handlers and create the handlers at shape constructor.
 
 * Delete handlers at destructor
 
 * Modify %%Render()%% method:
    - if selected, book to be rendered with handlers when possible and update handlers position.
    
 * Create method %%RenderWithHandlers()%%
 
 * Create method %%GetPointForHandler()%%
 
 * Create method %%OnHandlerDrag()%%
 
 * Create method %%OnHandlerEndDrag()%%

 * If necessary, override method %%OnSelectionStatusChanged()%% to hide or restore visibility of controlled shape while selected.



\h2 {Object points, object location, shapes and handlers}
%%%------------------------------------------------------

ScoreObjects defined by points instead of by glyphs (lines, ties, etc.) will have member variables of type %%lmTPoint%% (tenths). This points will be always relative to current object reference default point (%%m_paperPos%% or any default computed position). As a consequence, LDP data is interpreted as "user sift from the default reference point" and object points are always initialised with (0, 0) unless LDP data exist. Therefore:
 
    * LDP data about points can be mandatory (i.e. lines) or optional (i.e. ties).
    * Object does not need to implement method %%ComputeBestLocation()%%.
    * Object can ignore parameter %%uPos%% in method %%LayoutObject()%%.


%%*
[INTERNAL COMMENT]
In ties it is the shape who computes the positions. Notes create the shapes and shapes know how much space they occupy and how apart they should stay. This is a better model, as all knowledge about geometry is transferred to the right place: the shapes. Therefore, lmShapeTie should receive raw bezier data (user displacements) and apply them to "normal" geometry. That would be all!

And if a parent note (start or end of relationship) is moved, default values will apply again.
[END INTERNAL COMMENT]
*%%
